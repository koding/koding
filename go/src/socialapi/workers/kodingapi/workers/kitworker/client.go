package kitworker

import (
	"net/url"
	"strings"

	"github.com/go-kit/kit/circuitbreaker"
	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/loadbalancer"
	kitratelimit "github.com/go-kit/kit/ratelimit"
	"github.com/go-kit/kit/tracing/zipkin"
	httptransport "github.com/go-kit/kit/transport/http"
	jujuratelimit "github.com/juju/ratelimit"
	"github.com/sony/gobreaker"
)

// LoadBalancerF
type LoadBalancerF func(factory loadbalancer.Factory) loadbalancer.LoadBalancer

// ClientOption holds the required parameters for configuring a client
type ClientOption struct {
	// Host holds the host's name
	Host string

	// ZipkinCollector holds the collector for zipkin tracing
	ZipkinCollector zipkin.Collector

	// DisableCircuitBreaker disables circuit breaking functionality
	DisableCircuitBreaker bool

	// CircuitBreaker holds the custom circuit breaker, if not set a default one
	// will be created with default settings
	CircuitBreaker *gobreaker.CircuitBreaker

	// DisableRateLimiter disables rate limiting functionality
	DisableRateLimiter bool

	// QPS holds the configration parameter for rate limiting outgoing requests
	// to remote client. Must be set othervise all requests will be blocked
	// unless rate limiting is disabled
	QPS int

	// RateLimiter holds the custom rate limiter, if not set a default one will be created automatically
	RateLimiter *jujuratelimit.Bucket

	// TransportOpts holds custom httptransport.ClientOption array will be
	// appended to the end of the autogenerated ClientOptions
	TransportOpts []httptransport.ClientOption

	// Middlewares holds custom endpoint.Middleware array will be appended to
	// the end of the autogenerated Middlewares
	Middlewares []endpoint.Middleware

	// LoadBalancerCreator creates the loadbalancing strategy after getting the factory
	LoadBalancerCreator LoadBalancerF
}

// Configure prepares middlewares and clientOptions from the client options
//
// If required:
//   Adds circuitbreaker from "github.com/sony/gobreaker"
//   Adds ratelimiting from  "github.com/juju/ratelimit"
//   Adds request tracing from "github.com/go-kit/kit/tracing/zipkin"
func (c ClientOption) Configure(moduleName, funcName string) ([]endpoint.Middleware, []httptransport.ClientOption) {
	var transportOpts []httptransport.ClientOption
	var middlewares []endpoint.Middleware

	// if circuit braker is not disabled, add it as a middleware
	if !c.DisableCircuitBreaker {
		cb := c.CircuitBreaker

		if c.CircuitBreaker == nil {
			// create a default circuit breaker
			cb = gobreaker.NewCircuitBreaker(gobreaker.Settings{})
		}

		middlewares = append(middlewares, circuitbreaker.Gobreaker(cb))
	}

	// if rate limiter is not disabled, add it as a middleware
	if !c.DisableRateLimiter {
		rateLimiter := c.RateLimiter

		if c.RateLimiter == nil {
			// create a default rate limiter
			rateLimiter = jujuratelimit.NewBucketWithRate(float64(c.QPS), int64(c.QPS))
		}

		middlewares = append(middlewares, kitratelimit.NewTokenBucketLimiter(rateLimiter))
	}

	// enable tracing if required
	if c.Host != "" && c.ZipkinCollector != nil {
		endpointSpan := zipkin.MakeNewSpanFunc(c.Host, moduleName, funcName)
		// set tracing parameters to outgoing requests
		endpointTrace := zipkin.ToRequest(endpointSpan)
		// add tracing
		transportOpts = append(transportOpts, httptransport.SetClientBefore(endpointTrace))

		// add annotation as middleware to server
		middlewares = append(middlewares, zipkin.AnnotateClient(endpointSpan, c.ZipkinCollector))
	}

	// If any custom middlewares are passed include them
	if len(c.Middlewares) > 0 {
		middlewares = append(middlewares, c.Middlewares...)
	}

	// If any client options are passed include them in client creation
	if len(c.TransportOpts) > 0 {
		transportOpts = append(transportOpts, c.TransportOpts...)
	}

	return middlewares, transportOpts
}

// CreateProxyURL creates an URL as proxy URL
func CreateProxyURL(instance, endpoint string) *url.URL {
	if !strings.HasPrefix(instance, "http") {
		instance = "http://" + instance
	}
	u, err := url.Parse(instance)
	if err != nil {
		panic(err)
	}
	if u.Path == "" {
		u.Path = endpoint
	}

	return u
}
