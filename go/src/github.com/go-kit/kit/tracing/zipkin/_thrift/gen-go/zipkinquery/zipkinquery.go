// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package zipkinquery

import (
	"bytes"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
	"zipkincore"
	"zipkindependencies"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = zipkincore.GoUnusedProtection__
var _ = zipkindependencies.GoUnusedProtection__

type ZipkinQuery interface {
	// Parameters:
	//  - Request
	GetTraceIds(request *QueryRequest) (r *QueryResponse, err error)
	// Fetch trace ids by service and span name.
	// Gets "limit" number of entries from before the "end_ts".
	//
	// Span name is optional.
	// Timestamps are in microseconds.
	//
	// Parameters:
	//  - ServiceName
	//  - SpanName
	//  - EndTs
	//  - Limit
	//  - Order
	GetTraceIdsBySpanName(service_name string, span_name string, end_ts int64, limit int32, order Order) (r []int64, err error)
	// Fetch trace ids by service name.
	// Gets "limit" number of entries from before the "end_ts".
	//
	// Timestamps are in microseconds.
	//
	// Parameters:
	//  - ServiceName
	//  - EndTs
	//  - Limit
	//  - Order
	GetTraceIdsByServiceName(service_name string, end_ts int64, limit int32, order Order) (r []int64, err error)
	// Fetch trace ids with a particular annotation.
	// Gets "limit" number of entries from before the "end_ts".
	//
	// When requesting based on time based annotations only pass in the first parameter, "annotation" and leave out
	// the second "value". If looking for a key-value binary annotation provide both, "annotation" is then the
	// key in the key-value.
	//
	// Timestamps are in microseconds.
	//
	// Parameters:
	//  - ServiceName
	//  - Annotation
	//  - Value
	//  - EndTs
	//  - Limit
	//  - Order
	GetTraceIdsByAnnotation(service_name string, annotation string, value []byte, end_ts int64, limit int32, order Order) (r []int64, err error)
	// Get the traces that are in the database from the given list of trace ids.
	//
	// Parameters:
	//  - TraceIds
	TracesExist(trace_ids []int64) (r map[int64]bool, err error)
	// Get the full traces associated with the given trace ids.
	//
	// Second argument is a list of methods of adjusting the trace
	// data before returning it. Can be empty.
	//
	// Parameters:
	//  - TraceIds
	//  - Adjust
	GetTracesByIds(trace_ids []int64, adjust []Adjust) (r []*Trace, err error)
	// Get the trace timelines associated with the given trace ids.
	// This is a convenience method for users that just want to know
	// the annotations and the (assumed) order they happened in.
	//
	// Second argument is a list of methods of adjusting the trace
	// data before returning it. Can be empty.
	//
	// Note that if one of the trace ids does not have any data associated with it, it will not be
	// represented in the output list.
	//
	// Parameters:
	//  - TraceIds
	//  - Adjust
	GetTraceTimelinesByIds(trace_ids []int64, adjust []Adjust) (r []*TraceTimeline, err error)
	// Fetch trace summaries for the given trace ids.
	//
	// Second argument is a list of methods of adjusting the trace
	// data before returning it. Can be empty.
	//
	// Note that if one of the trace ids does not have any data associated with it, it will not be
	// represented in the output list.
	//
	// Parameters:
	//  - TraceIds
	//  - Adjust
	GetTraceSummariesByIds(trace_ids []int64, adjust []Adjust) (r []*TraceSummary, err error)
	// Not content with just one of traces, summaries or timelines? Want it all? This is the method for you.
	//
	// Parameters:
	//  - TraceIds
	//  - Adjust
	GetTraceCombosByIds(trace_ids []int64, adjust []Adjust) (r []*TraceCombo, err error)
	// Fetch all the service names we have seen from now all the way back to the set ttl.
	GetServiceNames() (r map[string]bool, err error)
	// Get all the seen span names for a particular service, from now back until the set ttl.
	//
	// Parameters:
	//  - ServiceName
	GetSpanNames(service_name string) (r map[string]bool, err error)
	// Change the TTL of a trace. If we find an interesting trace we want to keep around for further
	// investigation.
	//
	// Parameters:
	//  - TraceId
	//  - TtlSeconds
	SetTraceTimeToLive(trace_id int64, ttl_seconds int32) (err error)
	// Get the TTL in seconds of a specific trace.
	//
	// Parameters:
	//  - TraceId
	GetTraceTimeToLive(trace_id int64) (r int32, err error)
	// Get the data ttl. This is the number of seconds we keep the data around before deleting it.
	GetDataTimeToLive() (r int32, err error)
	// Get an aggregate representation of all services paired with every service they call in to.
	// This includes information on call counts and mean/stdDev/etc of call durations.  The two arguments
	// specify epoch time in microseconds. The end time is optional and defaults to one day after the
	// start time.
	//
	// Parameters:
	//  - StartTime
	//  - EndTime
	GetDependencies(start_time int64, end_time int64) (r *zipkindependencies.Dependencies, err error)
	// Parameters:
	//  - ServiceName
	GetTopAnnotations(service_name string) (r []string, err error)
	// Parameters:
	//  - ServiceName
	GetTopKeyValueAnnotations(service_name string) (r []string, err error)
	// Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired
	// with the lists of every span duration (list<i64>) from the server to client. The lists of span durations
	// include information on call counts and mean/stdDev/etc of call durations.
	//
	// The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps
	// contains the key - client_service_name and value - list<span_durations>.
	//
	// Parameters:
	//  - TimeStamp
	//  - ServiceName
	//  - RpcName
	GetSpanDurations(time_stamp int64, service_name string, rpc_name string) (r map[string][]int64, err error)
	// Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired
	// with the lists of every trace Ids (list<i64>) from the server to client.
	//
	// The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps
	// contains the key - client_service_name and value - list<trace_id>.
	//
	// Parameters:
	//  - TimeStamp
	//  - ServiceName
	//  - RpcName
	GetServiceNamesToTraceIds(time_stamp int64, service_name string, rpc_name string) (r map[string][]int64, err error)
}

type ZipkinQueryClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewZipkinQueryClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ZipkinQueryClient {
	return &ZipkinQueryClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewZipkinQueryClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ZipkinQueryClient {
	return &ZipkinQueryClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - Request
func (p *ZipkinQueryClient) GetTraceIds(request *QueryRequest) (r *QueryResponse, err error) {
	if err = p.sendGetTraceIds(request); err != nil {
		return
	}
	return p.recvGetTraceIds()
}

func (p *ZipkinQueryClient) sendGetTraceIds(request *QueryRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceIdsArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceIds() (value *QueryResponse, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error11 error
		error11, err = error10.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error11
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceIds failed: out of sequence response")
		return
	}
	result := GetTraceIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Fetch trace ids by service and span name.
// Gets "limit" number of entries from before the "end_ts".
//
// Span name is optional.
// Timestamps are in microseconds.
//
// Parameters:
//  - ServiceName
//  - SpanName
//  - EndTs
//  - Limit
//  - Order
func (p *ZipkinQueryClient) GetTraceIdsBySpanName(service_name string, span_name string, end_ts int64, limit int32, order Order) (r []int64, err error) {
	if err = p.sendGetTraceIdsBySpanName(service_name, span_name, end_ts, limit, order); err != nil {
		return
	}
	return p.recvGetTraceIdsBySpanName()
}

func (p *ZipkinQueryClient) sendGetTraceIdsBySpanName(service_name string, span_name string, end_ts int64, limit int32, order Order) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceIdsBySpanName", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceIdsBySpanNameArgs{
		ServiceName: service_name,
		SpanName:    span_name,
		EndTs:       end_ts,
		Limit:       limit,
		Order:       order,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceIdsBySpanName() (value []int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error12 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error13 error
		error13, err = error12.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error13
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceIdsBySpanName failed: out of sequence response")
		return
	}
	result := GetTraceIdsBySpanNameResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Fetch trace ids by service name.
// Gets "limit" number of entries from before the "end_ts".
//
// Timestamps are in microseconds.
//
// Parameters:
//  - ServiceName
//  - EndTs
//  - Limit
//  - Order
func (p *ZipkinQueryClient) GetTraceIdsByServiceName(service_name string, end_ts int64, limit int32, order Order) (r []int64, err error) {
	if err = p.sendGetTraceIdsByServiceName(service_name, end_ts, limit, order); err != nil {
		return
	}
	return p.recvGetTraceIdsByServiceName()
}

func (p *ZipkinQueryClient) sendGetTraceIdsByServiceName(service_name string, end_ts int64, limit int32, order Order) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceIdsByServiceName", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceIdsByServiceNameArgs{
		ServiceName: service_name,
		EndTs:       end_ts,
		Limit:       limit,
		Order:       order,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceIdsByServiceName() (value []int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error14 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error15 error
		error15, err = error14.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error15
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceIdsByServiceName failed: out of sequence response")
		return
	}
	result := GetTraceIdsByServiceNameResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Fetch trace ids with a particular annotation.
// Gets "limit" number of entries from before the "end_ts".
//
// When requesting based on time based annotations only pass in the first parameter, "annotation" and leave out
// the second "value". If looking for a key-value binary annotation provide both, "annotation" is then the
// key in the key-value.
//
// Timestamps are in microseconds.
//
// Parameters:
//  - ServiceName
//  - Annotation
//  - Value
//  - EndTs
//  - Limit
//  - Order
func (p *ZipkinQueryClient) GetTraceIdsByAnnotation(service_name string, annotation string, value []byte, end_ts int64, limit int32, order Order) (r []int64, err error) {
	if err = p.sendGetTraceIdsByAnnotation(service_name, annotation, value, end_ts, limit, order); err != nil {
		return
	}
	return p.recvGetTraceIdsByAnnotation()
}

func (p *ZipkinQueryClient) sendGetTraceIdsByAnnotation(service_name string, annotation string, value []byte, end_ts int64, limit int32, order Order) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceIdsByAnnotation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceIdsByAnnotationArgs{
		ServiceName: service_name,
		Annotation:  annotation,
		Value:       value,
		EndTs:       end_ts,
		Limit:       limit,
		Order:       order,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceIdsByAnnotation() (value []int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error16 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error17 error
		error17, err = error16.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error17
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceIdsByAnnotation failed: out of sequence response")
		return
	}
	result := GetTraceIdsByAnnotationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get the traces that are in the database from the given list of trace ids.
//
// Parameters:
//  - TraceIds
func (p *ZipkinQueryClient) TracesExist(trace_ids []int64) (r map[int64]bool, err error) {
	if err = p.sendTracesExist(trace_ids); err != nil {
		return
	}
	return p.recvTracesExist()
}

func (p *ZipkinQueryClient) sendTracesExist(trace_ids []int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("tracesExist", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TracesExistArgs{
		TraceIds: trace_ids,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvTracesExist() (value map[int64]bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error18 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error19 error
		error19, err = error18.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error19
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "tracesExist failed: out of sequence response")
		return
	}
	result := TracesExistResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get the full traces associated with the given trace ids.
//
// Second argument is a list of methods of adjusting the trace
// data before returning it. Can be empty.
//
// Parameters:
//  - TraceIds
//  - Adjust
func (p *ZipkinQueryClient) GetTracesByIds(trace_ids []int64, adjust []Adjust) (r []*Trace, err error) {
	if err = p.sendGetTracesByIds(trace_ids, adjust); err != nil {
		return
	}
	return p.recvGetTracesByIds()
}

func (p *ZipkinQueryClient) sendGetTracesByIds(trace_ids []int64, adjust []Adjust) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTracesByIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTracesByIdsArgs{
		TraceIds: trace_ids,
		Adjust:   adjust,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTracesByIds() (value []*Trace, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTracesByIds failed: out of sequence response")
		return
	}
	result := GetTracesByIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get the trace timelines associated with the given trace ids.
// This is a convenience method for users that just want to know
// the annotations and the (assumed) order they happened in.
//
// Second argument is a list of methods of adjusting the trace
// data before returning it. Can be empty.
//
// Note that if one of the trace ids does not have any data associated with it, it will not be
// represented in the output list.
//
// Parameters:
//  - TraceIds
//  - Adjust
func (p *ZipkinQueryClient) GetTraceTimelinesByIds(trace_ids []int64, adjust []Adjust) (r []*TraceTimeline, err error) {
	if err = p.sendGetTraceTimelinesByIds(trace_ids, adjust); err != nil {
		return
	}
	return p.recvGetTraceTimelinesByIds()
}

func (p *ZipkinQueryClient) sendGetTraceTimelinesByIds(trace_ids []int64, adjust []Adjust) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceTimelinesByIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceTimelinesByIdsArgs{
		TraceIds: trace_ids,
		Adjust:   adjust,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceTimelinesByIds() (value []*TraceTimeline, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceTimelinesByIds failed: out of sequence response")
		return
	}
	result := GetTraceTimelinesByIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Fetch trace summaries for the given trace ids.
//
// Second argument is a list of methods of adjusting the trace
// data before returning it. Can be empty.
//
// Note that if one of the trace ids does not have any data associated with it, it will not be
// represented in the output list.
//
// Parameters:
//  - TraceIds
//  - Adjust
func (p *ZipkinQueryClient) GetTraceSummariesByIds(trace_ids []int64, adjust []Adjust) (r []*TraceSummary, err error) {
	if err = p.sendGetTraceSummariesByIds(trace_ids, adjust); err != nil {
		return
	}
	return p.recvGetTraceSummariesByIds()
}

func (p *ZipkinQueryClient) sendGetTraceSummariesByIds(trace_ids []int64, adjust []Adjust) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceSummariesByIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceSummariesByIdsArgs{
		TraceIds: trace_ids,
		Adjust:   adjust,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceSummariesByIds() (value []*TraceSummary, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceSummariesByIds failed: out of sequence response")
		return
	}
	result := GetTraceSummariesByIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Not content with just one of traces, summaries or timelines? Want it all? This is the method for you.
//
// Parameters:
//  - TraceIds
//  - Adjust
func (p *ZipkinQueryClient) GetTraceCombosByIds(trace_ids []int64, adjust []Adjust) (r []*TraceCombo, err error) {
	if err = p.sendGetTraceCombosByIds(trace_ids, adjust); err != nil {
		return
	}
	return p.recvGetTraceCombosByIds()
}

func (p *ZipkinQueryClient) sendGetTraceCombosByIds(trace_ids []int64, adjust []Adjust) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceCombosByIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceCombosByIdsArgs{
		TraceIds: trace_ids,
		Adjust:   adjust,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceCombosByIds() (value []*TraceCombo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceCombosByIds failed: out of sequence response")
		return
	}
	result := GetTraceCombosByIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Fetch all the service names we have seen from now all the way back to the set ttl.
func (p *ZipkinQueryClient) GetServiceNames() (r map[string]bool, err error) {
	if err = p.sendGetServiceNames(); err != nil {
		return
	}
	return p.recvGetServiceNames()
}

func (p *ZipkinQueryClient) sendGetServiceNames() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getServiceNames", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetServiceNamesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetServiceNames() (value map[string]bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getServiceNames failed: out of sequence response")
		return
	}
	result := GetServiceNamesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get all the seen span names for a particular service, from now back until the set ttl.
//
// Parameters:
//  - ServiceName
func (p *ZipkinQueryClient) GetSpanNames(service_name string) (r map[string]bool, err error) {
	if err = p.sendGetSpanNames(service_name); err != nil {
		return
	}
	return p.recvGetSpanNames()
}

func (p *ZipkinQueryClient) sendGetSpanNames(service_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getSpanNames", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetSpanNamesArgs{
		ServiceName: service_name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetSpanNames() (value map[string]bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getSpanNames failed: out of sequence response")
		return
	}
	result := GetSpanNamesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Change the TTL of a trace. If we find an interesting trace we want to keep around for further
// investigation.
//
// Parameters:
//  - TraceId
//  - TtlSeconds
func (p *ZipkinQueryClient) SetTraceTimeToLive(trace_id int64, ttl_seconds int32) (err error) {
	if err = p.sendSetTraceTimeToLive(trace_id, ttl_seconds); err != nil {
		return
	}
	return p.recvSetTraceTimeToLive()
}

func (p *ZipkinQueryClient) sendSetTraceTimeToLive(trace_id int64, ttl_seconds int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("setTraceTimeToLive", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SetTraceTimeToLiveArgs{
		TraceId:    trace_id,
		TtlSeconds: ttl_seconds,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvSetTraceTimeToLive() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "setTraceTimeToLive failed: out of sequence response")
		return
	}
	result := SetTraceTimeToLiveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	return
}

// Get the TTL in seconds of a specific trace.
//
// Parameters:
//  - TraceId
func (p *ZipkinQueryClient) GetTraceTimeToLive(trace_id int64) (r int32, err error) {
	if err = p.sendGetTraceTimeToLive(trace_id); err != nil {
		return
	}
	return p.recvGetTraceTimeToLive()
}

func (p *ZipkinQueryClient) sendGetTraceTimeToLive(trace_id int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTraceTimeToLive", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTraceTimeToLiveArgs{
		TraceId: trace_id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTraceTimeToLive() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTraceTimeToLive failed: out of sequence response")
		return
	}
	result := GetTraceTimeToLiveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get the data ttl. This is the number of seconds we keep the data around before deleting it.
func (p *ZipkinQueryClient) GetDataTimeToLive() (r int32, err error) {
	if err = p.sendGetDataTimeToLive(); err != nil {
		return
	}
	return p.recvGetDataTimeToLive()
}

func (p *ZipkinQueryClient) sendGetDataTimeToLive() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getDataTimeToLive", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetDataTimeToLiveArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetDataTimeToLive() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getDataTimeToLive failed: out of sequence response")
		return
	}
	result := GetDataTimeToLiveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Get an aggregate representation of all services paired with every service they call in to.
// This includes information on call counts and mean/stdDev/etc of call durations.  The two arguments
// specify epoch time in microseconds. The end time is optional and defaults to one day after the
// start time.
//
// Parameters:
//  - StartTime
//  - EndTime
func (p *ZipkinQueryClient) GetDependencies(start_time int64, end_time int64) (r *zipkindependencies.Dependencies, err error) {
	if err = p.sendGetDependencies(start_time, end_time); err != nil {
		return
	}
	return p.recvGetDependencies()
}

func (p *ZipkinQueryClient) sendGetDependencies(start_time int64, end_time int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getDependencies", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetDependenciesArgs{
		StartTime: start_time,
		EndTime:   end_time,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetDependencies() (value *zipkindependencies.Dependencies, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getDependencies failed: out of sequence response")
		return
	}
	result := GetDependenciesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - ServiceName
func (p *ZipkinQueryClient) GetTopAnnotations(service_name string) (r []string, err error) {
	if err = p.sendGetTopAnnotations(service_name); err != nil {
		return
	}
	return p.recvGetTopAnnotations()
}

func (p *ZipkinQueryClient) sendGetTopAnnotations(service_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTopAnnotations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTopAnnotationsArgs{
		ServiceName: service_name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTopAnnotations() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTopAnnotations failed: out of sequence response")
		return
	}
	result := GetTopAnnotationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - ServiceName
func (p *ZipkinQueryClient) GetTopKeyValueAnnotations(service_name string) (r []string, err error) {
	if err = p.sendGetTopKeyValueAnnotations(service_name); err != nil {
		return
	}
	return p.recvGetTopKeyValueAnnotations()
}

func (p *ZipkinQueryClient) sendGetTopKeyValueAnnotations(service_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTopKeyValueAnnotations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTopKeyValueAnnotationsArgs{
		ServiceName: service_name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetTopKeyValueAnnotations() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTopKeyValueAnnotations failed: out of sequence response")
		return
	}
	result := GetTopKeyValueAnnotationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Qe != nil {
		err = result.Qe
		return
	}
	value = result.GetSuccess()
	return
}

// Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired
// with the lists of every span duration (list<i64>) from the server to client. The lists of span durations
// include information on call counts and mean/stdDev/etc of call durations.
//
// The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps
// contains the key - client_service_name and value - list<span_durations>.
//
// Parameters:
//  - TimeStamp
//  - ServiceName
//  - RpcName
func (p *ZipkinQueryClient) GetSpanDurations(time_stamp int64, service_name string, rpc_name string) (r map[string][]int64, err error) {
	if err = p.sendGetSpanDurations(time_stamp, service_name, rpc_name); err != nil {
		return
	}
	return p.recvGetSpanDurations()
}

func (p *ZipkinQueryClient) sendGetSpanDurations(time_stamp int64, service_name string, rpc_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getSpanDurations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetSpanDurationsArgs{
		TimeStamp:   time_stamp,
		ServiceName: service_name,
		RpcName:     rpc_name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetSpanDurations() (value map[string][]int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getSpanDurations failed: out of sequence response")
		return
	}
	result := GetSpanDurationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Given a time stamp, server service name, and rpc name, fetch all of the client services calling in paired
// with the lists of every trace Ids (list<i64>) from the server to client.
//
// The three arguments specify epoch time in microseconds, server side service name and rpc name. The return maps
// contains the key - client_service_name and value - list<trace_id>.
//
// Parameters:
//  - TimeStamp
//  - ServiceName
//  - RpcName
func (p *ZipkinQueryClient) GetServiceNamesToTraceIds(time_stamp int64, service_name string, rpc_name string) (r map[string][]int64, err error) {
	if err = p.sendGetServiceNamesToTraceIds(time_stamp, service_name, rpc_name); err != nil {
		return
	}
	return p.recvGetServiceNamesToTraceIds()
}

func (p *ZipkinQueryClient) sendGetServiceNamesToTraceIds(time_stamp int64, service_name string, rpc_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getServiceNamesToTraceIds", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetServiceNamesToTraceIdsArgs{
		TimeStamp:   time_stamp,
		ServiceName: service_name,
		RpcName:     rpc_name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ZipkinQueryClient) recvGetServiceNamesToTraceIds() (value map[string][]int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getServiceNamesToTraceIds failed: out of sequence response")
		return
	}
	result := GetServiceNamesToTraceIdsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type ZipkinQueryProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ZipkinQuery
}

func (p *ZipkinQueryProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ZipkinQueryProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ZipkinQueryProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewZipkinQueryProcessor(handler ZipkinQuery) *ZipkinQueryProcessor {

	self48 := &ZipkinQueryProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self48.processorMap["getTraceIds"] = &zipkinQueryProcessorGetTraceIds{handler: handler}
	self48.processorMap["getTraceIdsBySpanName"] = &zipkinQueryProcessorGetTraceIdsBySpanName{handler: handler}
	self48.processorMap["getTraceIdsByServiceName"] = &zipkinQueryProcessorGetTraceIdsByServiceName{handler: handler}
	self48.processorMap["getTraceIdsByAnnotation"] = &zipkinQueryProcessorGetTraceIdsByAnnotation{handler: handler}
	self48.processorMap["tracesExist"] = &zipkinQueryProcessorTracesExist{handler: handler}
	self48.processorMap["getTracesByIds"] = &zipkinQueryProcessorGetTracesByIds{handler: handler}
	self48.processorMap["getTraceTimelinesByIds"] = &zipkinQueryProcessorGetTraceTimelinesByIds{handler: handler}
	self48.processorMap["getTraceSummariesByIds"] = &zipkinQueryProcessorGetTraceSummariesByIds{handler: handler}
	self48.processorMap["getTraceCombosByIds"] = &zipkinQueryProcessorGetTraceCombosByIds{handler: handler}
	self48.processorMap["getServiceNames"] = &zipkinQueryProcessorGetServiceNames{handler: handler}
	self48.processorMap["getSpanNames"] = &zipkinQueryProcessorGetSpanNames{handler: handler}
	self48.processorMap["setTraceTimeToLive"] = &zipkinQueryProcessorSetTraceTimeToLive{handler: handler}
	self48.processorMap["getTraceTimeToLive"] = &zipkinQueryProcessorGetTraceTimeToLive{handler: handler}
	self48.processorMap["getDataTimeToLive"] = &zipkinQueryProcessorGetDataTimeToLive{handler: handler}
	self48.processorMap["getDependencies"] = &zipkinQueryProcessorGetDependencies{handler: handler}
	self48.processorMap["getTopAnnotations"] = &zipkinQueryProcessorGetTopAnnotations{handler: handler}
	self48.processorMap["getTopKeyValueAnnotations"] = &zipkinQueryProcessorGetTopKeyValueAnnotations{handler: handler}
	self48.processorMap["getSpanDurations"] = &zipkinQueryProcessorGetSpanDurations{handler: handler}
	self48.processorMap["getServiceNamesToTraceIds"] = &zipkinQueryProcessorGetServiceNamesToTraceIds{handler: handler}
	return self48
}

func (p *ZipkinQueryProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x49 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x49.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x49

}

type zipkinQueryProcessorGetTraceIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceIdsResult{}
	var retval *QueryResponse
	var err2 error
	if retval, err2 = p.handler.GetTraceIds(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceIds: "+err2.Error())
			oprot.WriteMessageBegin("getTraceIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceIdsBySpanName struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceIdsBySpanName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceIdsBySpanNameArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceIdsBySpanName", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceIdsBySpanNameResult{}
	var retval []int64
	var err2 error
	if retval, err2 = p.handler.GetTraceIdsBySpanName(args.ServiceName, args.SpanName, args.EndTs, args.Limit, args.Order); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceIdsBySpanName: "+err2.Error())
			oprot.WriteMessageBegin("getTraceIdsBySpanName", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceIdsBySpanName", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceIdsByServiceName struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceIdsByServiceName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceIdsByServiceNameArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceIdsByServiceName", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceIdsByServiceNameResult{}
	var retval []int64
	var err2 error
	if retval, err2 = p.handler.GetTraceIdsByServiceName(args.ServiceName, args.EndTs, args.Limit, args.Order); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceIdsByServiceName: "+err2.Error())
			oprot.WriteMessageBegin("getTraceIdsByServiceName", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceIdsByServiceName", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceIdsByAnnotation struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceIdsByAnnotation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceIdsByAnnotationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceIdsByAnnotation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceIdsByAnnotationResult{}
	var retval []int64
	var err2 error
	if retval, err2 = p.handler.GetTraceIdsByAnnotation(args.ServiceName, args.Annotation, args.Value, args.EndTs, args.Limit, args.Order); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceIdsByAnnotation: "+err2.Error())
			oprot.WriteMessageBegin("getTraceIdsByAnnotation", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceIdsByAnnotation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorTracesExist struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorTracesExist) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TracesExistArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("tracesExist", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TracesExistResult{}
	var retval map[int64]bool
	var err2 error
	if retval, err2 = p.handler.TracesExist(args.TraceIds); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tracesExist: "+err2.Error())
			oprot.WriteMessageBegin("tracesExist", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("tracesExist", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTracesByIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTracesByIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTracesByIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTracesByIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTracesByIdsResult{}
	var retval []*Trace
	var err2 error
	if retval, err2 = p.handler.GetTracesByIds(args.TraceIds, args.Adjust); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTracesByIds: "+err2.Error())
			oprot.WriteMessageBegin("getTracesByIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTracesByIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceTimelinesByIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceTimelinesByIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceTimelinesByIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceTimelinesByIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceTimelinesByIdsResult{}
	var retval []*TraceTimeline
	var err2 error
	if retval, err2 = p.handler.GetTraceTimelinesByIds(args.TraceIds, args.Adjust); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceTimelinesByIds: "+err2.Error())
			oprot.WriteMessageBegin("getTraceTimelinesByIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceTimelinesByIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceSummariesByIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceSummariesByIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceSummariesByIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceSummariesByIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceSummariesByIdsResult{}
	var retval []*TraceSummary
	var err2 error
	if retval, err2 = p.handler.GetTraceSummariesByIds(args.TraceIds, args.Adjust); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceSummariesByIds: "+err2.Error())
			oprot.WriteMessageBegin("getTraceSummariesByIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceSummariesByIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceCombosByIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceCombosByIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceCombosByIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceCombosByIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceCombosByIdsResult{}
	var retval []*TraceCombo
	var err2 error
	if retval, err2 = p.handler.GetTraceCombosByIds(args.TraceIds, args.Adjust); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceCombosByIds: "+err2.Error())
			oprot.WriteMessageBegin("getTraceCombosByIds", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceCombosByIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetServiceNames struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetServiceNames) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetServiceNamesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getServiceNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetServiceNamesResult{}
	var retval map[string]bool
	var err2 error
	if retval, err2 = p.handler.GetServiceNames(); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getServiceNames: "+err2.Error())
			oprot.WriteMessageBegin("getServiceNames", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getServiceNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetSpanNames struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetSpanNames) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetSpanNamesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getSpanNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetSpanNamesResult{}
	var retval map[string]bool
	var err2 error
	if retval, err2 = p.handler.GetSpanNames(args.ServiceName); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSpanNames: "+err2.Error())
			oprot.WriteMessageBegin("getSpanNames", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getSpanNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorSetTraceTimeToLive struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorSetTraceTimeToLive) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SetTraceTimeToLiveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("setTraceTimeToLive", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SetTraceTimeToLiveResult{}
	var err2 error
	if err2 = p.handler.SetTraceTimeToLive(args.TraceId, args.TtlSeconds); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setTraceTimeToLive: "+err2.Error())
			oprot.WriteMessageBegin("setTraceTimeToLive", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("setTraceTimeToLive", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTraceTimeToLive struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTraceTimeToLive) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTraceTimeToLiveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTraceTimeToLive", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTraceTimeToLiveResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.GetTraceTimeToLive(args.TraceId); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTraceTimeToLive: "+err2.Error())
			oprot.WriteMessageBegin("getTraceTimeToLive", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getTraceTimeToLive", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetDataTimeToLive struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetDataTimeToLive) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetDataTimeToLiveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getDataTimeToLive", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetDataTimeToLiveResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.GetDataTimeToLive(); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getDataTimeToLive: "+err2.Error())
			oprot.WriteMessageBegin("getDataTimeToLive", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getDataTimeToLive", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetDependencies struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetDependencies) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetDependenciesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getDependencies", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetDependenciesResult{}
	var retval *zipkindependencies.Dependencies
	var err2 error
	if retval, err2 = p.handler.GetDependencies(args.StartTime, args.EndTime); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getDependencies: "+err2.Error())
			oprot.WriteMessageBegin("getDependencies", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getDependencies", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTopAnnotations struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTopAnnotations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTopAnnotationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTopAnnotations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTopAnnotationsResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.GetTopAnnotations(args.ServiceName); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTopAnnotations: "+err2.Error())
			oprot.WriteMessageBegin("getTopAnnotations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTopAnnotations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetTopKeyValueAnnotations struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetTopKeyValueAnnotations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTopKeyValueAnnotationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTopKeyValueAnnotations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTopKeyValueAnnotationsResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.GetTopKeyValueAnnotations(args.ServiceName); err2 != nil {
		switch v := err2.(type) {
		case *QueryException:
			result.Qe = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTopKeyValueAnnotations: "+err2.Error())
			oprot.WriteMessageBegin("getTopKeyValueAnnotations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTopKeyValueAnnotations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetSpanDurations struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetSpanDurations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetSpanDurationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getSpanDurations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetSpanDurationsResult{}
	var retval map[string][]int64
	var err2 error
	if retval, err2 = p.handler.GetSpanDurations(args.TimeStamp, args.ServiceName, args.RpcName); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSpanDurations: "+err2.Error())
		oprot.WriteMessageBegin("getSpanDurations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getSpanDurations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type zipkinQueryProcessorGetServiceNamesToTraceIds struct {
	handler ZipkinQuery
}

func (p *zipkinQueryProcessorGetServiceNamesToTraceIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetServiceNamesToTraceIdsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getServiceNamesToTraceIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetServiceNamesToTraceIdsResult{}
	var retval map[string][]int64
	var err2 error
	if retval, err2 = p.handler.GetServiceNamesToTraceIds(args.TimeStamp, args.ServiceName, args.RpcName); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getServiceNamesToTraceIds: "+err2.Error())
		oprot.WriteMessageBegin("getServiceNamesToTraceIds", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getServiceNamesToTraceIds", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type GetTraceIdsArgs struct {
	Request *QueryRequest `thrift:"request,1" json:"request"`
}

func NewGetTraceIdsArgs() *GetTraceIdsArgs {
	return &GetTraceIdsArgs{}
}

var GetTraceIdsArgs_Request_DEFAULT *QueryRequest

func (p *GetTraceIdsArgs) GetRequest() *QueryRequest {
	if !p.IsSetRequest() {
		return GetTraceIdsArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *GetTraceIdsArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *GetTraceIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &QueryRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *GetTraceIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsArgs(%+v)", *p)
}

type GetTraceIdsResult struct {
	Success *QueryResponse  `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceIdsResult() *GetTraceIdsResult {
	return &GetTraceIdsResult{}
}

var GetTraceIdsResult_Success_DEFAULT *QueryResponse

func (p *GetTraceIdsResult) GetSuccess() *QueryResponse {
	if !p.IsSetSuccess() {
		return GetTraceIdsResult_Success_DEFAULT
	}
	return p.Success
}

var GetTraceIdsResult_Qe_DEFAULT *QueryException

func (p *GetTraceIdsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceIdsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceIdsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &QueryResponse{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTraceIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsResult(%+v)", *p)
}

type GetTraceIdsBySpanNameArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
	SpanName    string `thrift:"span_name,2" json:"span_name"`
	// unused field # 3
	EndTs int64 `thrift:"end_ts,4" json:"end_ts"`
	Limit int32 `thrift:"limit,5" json:"limit"`
	Order Order `thrift:"order,6" json:"order"`
}

func NewGetTraceIdsBySpanNameArgs() *GetTraceIdsBySpanNameArgs {
	return &GetTraceIdsBySpanNameArgs{}
}

func (p *GetTraceIdsBySpanNameArgs) GetServiceName() string {
	return p.ServiceName
}

func (p *GetTraceIdsBySpanNameArgs) GetSpanName() string {
	return p.SpanName
}

func (p *GetTraceIdsBySpanNameArgs) GetEndTs() int64 {
	return p.EndTs
}

func (p *GetTraceIdsBySpanNameArgs) GetLimit() int32 {
	return p.Limit
}

func (p *GetTraceIdsBySpanNameArgs) GetOrder() Order {
	return p.Order
}
func (p *GetTraceIdsBySpanNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.SpanName = v
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.EndTs = v
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Limit = v
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		temp := Order(v)
		p.Order = temp
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsBySpanName_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsBySpanNameArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("span_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:span_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.SpanName)); err != nil {
		return fmt.Errorf("%T.span_name (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:span_name: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsBySpanNameArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_ts", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:end_ts: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.EndTs)); err != nil {
		return fmt.Errorf("%T.end_ts (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:end_ts: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsBySpanNameArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("limit", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:limit: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Limit)); err != nil {
		return fmt.Errorf("%T.limit (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:limit: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsBySpanNameArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("order", thrift.I32, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:order: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Order)); err != nil {
		return fmt.Errorf("%T.order (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:order: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsBySpanNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsBySpanNameArgs(%+v)", *p)
}

type GetTraceIdsBySpanNameResult struct {
	Success []int64         `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceIdsBySpanNameResult() *GetTraceIdsBySpanNameResult {
	return &GetTraceIdsBySpanNameResult{}
}

var GetTraceIdsBySpanNameResult_Success_DEFAULT []int64

func (p *GetTraceIdsBySpanNameResult) GetSuccess() []int64 {
	return p.Success
}

var GetTraceIdsBySpanNameResult_Qe_DEFAULT *QueryException

func (p *GetTraceIdsBySpanNameResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceIdsBySpanNameResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceIdsBySpanNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceIdsBySpanNameResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceIdsBySpanNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem50 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem50 = v
		}
		p.Success = append(p.Success, _elem50)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsBySpanName_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsBySpanNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.I64, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteI64(int64(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsBySpanNameResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsBySpanNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsBySpanNameResult(%+v)", *p)
}

type GetTraceIdsByServiceNameArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
	// unused field # 2
	EndTs int64 `thrift:"end_ts,3" json:"end_ts"`
	Limit int32 `thrift:"limit,4" json:"limit"`
	Order Order `thrift:"order,5" json:"order"`
}

func NewGetTraceIdsByServiceNameArgs() *GetTraceIdsByServiceNameArgs {
	return &GetTraceIdsByServiceNameArgs{}
}

func (p *GetTraceIdsByServiceNameArgs) GetServiceName() string {
	return p.ServiceName
}

func (p *GetTraceIdsByServiceNameArgs) GetEndTs() int64 {
	return p.EndTs
}

func (p *GetTraceIdsByServiceNameArgs) GetLimit() int32 {
	return p.Limit
}

func (p *GetTraceIdsByServiceNameArgs) GetOrder() Order {
	return p.Order
}
func (p *GetTraceIdsByServiceNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.EndTs = v
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Limit = v
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		temp := Order(v)
		p.Order = temp
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsByServiceName_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByServiceNameArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_ts", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_ts: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.EndTs)); err != nil {
		return fmt.Errorf("%T.end_ts (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_ts: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByServiceNameArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("limit", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:limit: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Limit)); err != nil {
		return fmt.Errorf("%T.limit (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:limit: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByServiceNameArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("order", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:order: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Order)); err != nil {
		return fmt.Errorf("%T.order (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:order: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByServiceNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsByServiceNameArgs(%+v)", *p)
}

type GetTraceIdsByServiceNameResult struct {
	Success []int64         `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceIdsByServiceNameResult() *GetTraceIdsByServiceNameResult {
	return &GetTraceIdsByServiceNameResult{}
}

var GetTraceIdsByServiceNameResult_Success_DEFAULT []int64

func (p *GetTraceIdsByServiceNameResult) GetSuccess() []int64 {
	return p.Success
}

var GetTraceIdsByServiceNameResult_Qe_DEFAULT *QueryException

func (p *GetTraceIdsByServiceNameResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceIdsByServiceNameResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceIdsByServiceNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceIdsByServiceNameResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceIdsByServiceNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem51 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem51 = v
		}
		p.Success = append(p.Success, _elem51)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsByServiceName_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByServiceNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.I64, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteI64(int64(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsByServiceNameResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsByServiceNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsByServiceNameResult(%+v)", *p)
}

type GetTraceIdsByAnnotationArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
	Annotation  string `thrift:"annotation,2" json:"annotation"`
	Value       []byte `thrift:"value,3" json:"value"`
	// unused field # 4
	EndTs int64 `thrift:"end_ts,5" json:"end_ts"`
	Limit int32 `thrift:"limit,6" json:"limit"`
	Order Order `thrift:"order,7" json:"order"`
}

func NewGetTraceIdsByAnnotationArgs() *GetTraceIdsByAnnotationArgs {
	return &GetTraceIdsByAnnotationArgs{}
}

func (p *GetTraceIdsByAnnotationArgs) GetServiceName() string {
	return p.ServiceName
}

func (p *GetTraceIdsByAnnotationArgs) GetAnnotation() string {
	return p.Annotation
}

func (p *GetTraceIdsByAnnotationArgs) GetValue() []byte {
	return p.Value
}

func (p *GetTraceIdsByAnnotationArgs) GetEndTs() int64 {
	return p.EndTs
}

func (p *GetTraceIdsByAnnotationArgs) GetLimit() int32 {
	return p.Limit
}

func (p *GetTraceIdsByAnnotationArgs) GetOrder() Order {
	return p.Order
}
func (p *GetTraceIdsByAnnotationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.ReadField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Annotation = v
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.EndTs = v
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.Limit = v
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) ReadField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 7: %s", err)
	} else {
		temp := Order(v)
		p.Order = temp
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsByAnnotation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("annotation", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:annotation: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Annotation)); err != nil {
		return fmt.Errorf("%T.annotation (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:annotation: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:value: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_ts", thrift.I64, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:end_ts: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.EndTs)); err != nil {
		return fmt.Errorf("%T.end_ts (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:end_ts: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("limit", thrift.I32, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:limit: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Limit)); err != nil {
		return fmt.Errorf("%T.limit (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:limit: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("order", thrift.I32, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:order: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Order)); err != nil {
		return fmt.Errorf("%T.order (7) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:order: %s", p, err)
	}
	return err
}

func (p *GetTraceIdsByAnnotationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsByAnnotationArgs(%+v)", *p)
}

type GetTraceIdsByAnnotationResult struct {
	Success []int64         `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceIdsByAnnotationResult() *GetTraceIdsByAnnotationResult {
	return &GetTraceIdsByAnnotationResult{}
}

var GetTraceIdsByAnnotationResult_Success_DEFAULT []int64

func (p *GetTraceIdsByAnnotationResult) GetSuccess() []int64 {
	return p.Success
}

var GetTraceIdsByAnnotationResult_Qe_DEFAULT *QueryException

func (p *GetTraceIdsByAnnotationResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceIdsByAnnotationResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceIdsByAnnotationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceIdsByAnnotationResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceIdsByAnnotationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem52 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem52 = v
		}
		p.Success = append(p.Success, _elem52)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceIdsByAnnotation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceIdsByAnnotationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.I64, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteI64(int64(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsByAnnotationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceIdsByAnnotationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceIdsByAnnotationResult(%+v)", *p)
}

type TracesExistArgs struct {
	TraceIds []int64 `thrift:"trace_ids,1" json:"trace_ids"`
}

func NewTracesExistArgs() *TracesExistArgs {
	return &TracesExistArgs{}
}

func (p *TracesExistArgs) GetTraceIds() []int64 {
	return p.TraceIds
}
func (p *TracesExistArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TracesExistArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.TraceIds = tSlice
	for i := 0; i < size; i++ {
		var _elem53 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem53 = v
		}
		p.TraceIds = append(p.TraceIds, _elem53)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TracesExistArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tracesExist_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TracesExistArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_ids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.TraceIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.TraceIds {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_ids: %s", p, err)
	}
	return err
}

func (p *TracesExistArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TracesExistArgs(%+v)", *p)
}

type TracesExistResult struct {
	Success map[int64]bool  `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewTracesExistResult() *TracesExistResult {
	return &TracesExistResult{}
}

var TracesExistResult_Success_DEFAULT map[int64]bool

func (p *TracesExistResult) GetSuccess() map[int64]bool {
	return p.Success
}

var TracesExistResult_Qe_DEFAULT *QueryException

func (p *TracesExistResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return TracesExistResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *TracesExistResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TracesExistResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *TracesExistResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TracesExistResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[int64]bool, size)
	p.Success = tSet
	for i := 0; i < size; i++ {
		var _elem54 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem54 = v
		}
		p.Success[_elem54] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *TracesExistResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *TracesExistResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tracesExist_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TracesExistResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.SET, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteSetBegin(thrift.I64, len(p.Success)); err != nil {
			return fmt.Errorf("error writing set begin: %s", err)
		}
		for v, _ := range p.Success {
			if err := oprot.WriteI64(int64(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteSetEnd(); err != nil {
			return fmt.Errorf("error writing set end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TracesExistResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *TracesExistResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TracesExistResult(%+v)", *p)
}

type GetTracesByIdsArgs struct {
	TraceIds []int64  `thrift:"trace_ids,1" json:"trace_ids"`
	Adjust   []Adjust `thrift:"adjust,2" json:"adjust"`
}

func NewGetTracesByIdsArgs() *GetTracesByIdsArgs {
	return &GetTracesByIdsArgs{}
}

func (p *GetTracesByIdsArgs) GetTraceIds() []int64 {
	return p.TraceIds
}

func (p *GetTracesByIdsArgs) GetAdjust() []Adjust {
	return p.Adjust
}
func (p *GetTracesByIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTracesByIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.TraceIds = tSlice
	for i := 0; i < size; i++ {
		var _elem55 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem55 = v
		}
		p.TraceIds = append(p.TraceIds, _elem55)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTracesByIdsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Adjust, 0, size)
	p.Adjust = tSlice
	for i := 0; i < size; i++ {
		var _elem56 Adjust
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Adjust(v)
			_elem56 = temp
		}
		p.Adjust = append(p.Adjust, _elem56)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTracesByIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTracesByIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTracesByIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_ids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.TraceIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.TraceIds {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_ids: %s", p, err)
	}
	return err
}

func (p *GetTracesByIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("adjust", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:adjust: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I32, len(p.Adjust)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Adjust {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:adjust: %s", p, err)
	}
	return err
}

func (p *GetTracesByIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTracesByIdsArgs(%+v)", *p)
}

type GetTracesByIdsResult struct {
	Success []*Trace        `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTracesByIdsResult() *GetTracesByIdsResult {
	return &GetTracesByIdsResult{}
}

var GetTracesByIdsResult_Success_DEFAULT []*Trace

func (p *GetTracesByIdsResult) GetSuccess() []*Trace {
	return p.Success
}

var GetTracesByIdsResult_Qe_DEFAULT *QueryException

func (p *GetTracesByIdsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTracesByIdsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTracesByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTracesByIdsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTracesByIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTracesByIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Trace, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem57 := &Trace{}
		if err := _elem57.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem57, err)
		}
		p.Success = append(p.Success, _elem57)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTracesByIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTracesByIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTracesByIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTracesByIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTracesByIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTracesByIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTracesByIdsResult(%+v)", *p)
}

type GetTraceTimelinesByIdsArgs struct {
	TraceIds []int64  `thrift:"trace_ids,1" json:"trace_ids"`
	Adjust   []Adjust `thrift:"adjust,2" json:"adjust"`
}

func NewGetTraceTimelinesByIdsArgs() *GetTraceTimelinesByIdsArgs {
	return &GetTraceTimelinesByIdsArgs{}
}

func (p *GetTraceTimelinesByIdsArgs) GetTraceIds() []int64 {
	return p.TraceIds
}

func (p *GetTraceTimelinesByIdsArgs) GetAdjust() []Adjust {
	return p.Adjust
}
func (p *GetTraceTimelinesByIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.TraceIds = tSlice
	for i := 0; i < size; i++ {
		var _elem58 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem58 = v
		}
		p.TraceIds = append(p.TraceIds, _elem58)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Adjust, 0, size)
	p.Adjust = tSlice
	for i := 0; i < size; i++ {
		var _elem59 Adjust
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Adjust(v)
			_elem59 = temp
		}
		p.Adjust = append(p.Adjust, _elem59)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceTimelinesByIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_ids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.TraceIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.TraceIds {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_ids: %s", p, err)
	}
	return err
}

func (p *GetTraceTimelinesByIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("adjust", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:adjust: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I32, len(p.Adjust)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Adjust {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:adjust: %s", p, err)
	}
	return err
}

func (p *GetTraceTimelinesByIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceTimelinesByIdsArgs(%+v)", *p)
}

type GetTraceTimelinesByIdsResult struct {
	Success []*TraceTimeline `thrift:"success,0" json:"success"`
	Qe      *QueryException  `thrift:"qe,1" json:"qe"`
}

func NewGetTraceTimelinesByIdsResult() *GetTraceTimelinesByIdsResult {
	return &GetTraceTimelinesByIdsResult{}
}

var GetTraceTimelinesByIdsResult_Success_DEFAULT []*TraceTimeline

func (p *GetTraceTimelinesByIdsResult) GetSuccess() []*TraceTimeline {
	return p.Success
}

var GetTraceTimelinesByIdsResult_Qe_DEFAULT *QueryException

func (p *GetTraceTimelinesByIdsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceTimelinesByIdsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceTimelinesByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceTimelinesByIdsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceTimelinesByIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TraceTimeline, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem60 := &TraceTimeline{}
		if err := _elem60.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem60, err)
		}
		p.Success = append(p.Success, _elem60)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceTimelinesByIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceTimelinesByIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceTimelinesByIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceTimelinesByIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceTimelinesByIdsResult(%+v)", *p)
}

type GetTraceSummariesByIdsArgs struct {
	TraceIds []int64  `thrift:"trace_ids,1" json:"trace_ids"`
	Adjust   []Adjust `thrift:"adjust,2" json:"adjust"`
}

func NewGetTraceSummariesByIdsArgs() *GetTraceSummariesByIdsArgs {
	return &GetTraceSummariesByIdsArgs{}
}

func (p *GetTraceSummariesByIdsArgs) GetTraceIds() []int64 {
	return p.TraceIds
}

func (p *GetTraceSummariesByIdsArgs) GetAdjust() []Adjust {
	return p.Adjust
}
func (p *GetTraceSummariesByIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.TraceIds = tSlice
	for i := 0; i < size; i++ {
		var _elem61 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem61 = v
		}
		p.TraceIds = append(p.TraceIds, _elem61)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Adjust, 0, size)
	p.Adjust = tSlice
	for i := 0; i < size; i++ {
		var _elem62 Adjust
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Adjust(v)
			_elem62 = temp
		}
		p.Adjust = append(p.Adjust, _elem62)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceSummariesByIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_ids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.TraceIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.TraceIds {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_ids: %s", p, err)
	}
	return err
}

func (p *GetTraceSummariesByIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("adjust", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:adjust: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I32, len(p.Adjust)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Adjust {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:adjust: %s", p, err)
	}
	return err
}

func (p *GetTraceSummariesByIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceSummariesByIdsArgs(%+v)", *p)
}

type GetTraceSummariesByIdsResult struct {
	Success []*TraceSummary `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceSummariesByIdsResult() *GetTraceSummariesByIdsResult {
	return &GetTraceSummariesByIdsResult{}
}

var GetTraceSummariesByIdsResult_Success_DEFAULT []*TraceSummary

func (p *GetTraceSummariesByIdsResult) GetSuccess() []*TraceSummary {
	return p.Success
}

var GetTraceSummariesByIdsResult_Qe_DEFAULT *QueryException

func (p *GetTraceSummariesByIdsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceSummariesByIdsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceSummariesByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceSummariesByIdsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceSummariesByIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TraceSummary, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem63 := &TraceSummary{}
		if err := _elem63.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem63, err)
		}
		p.Success = append(p.Success, _elem63)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceSummariesByIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceSummariesByIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceSummariesByIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceSummariesByIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceSummariesByIdsResult(%+v)", *p)
}

type GetTraceCombosByIdsArgs struct {
	TraceIds []int64  `thrift:"trace_ids,1" json:"trace_ids"`
	Adjust   []Adjust `thrift:"adjust,2" json:"adjust"`
}

func NewGetTraceCombosByIdsArgs() *GetTraceCombosByIdsArgs {
	return &GetTraceCombosByIdsArgs{}
}

func (p *GetTraceCombosByIdsArgs) GetTraceIds() []int64 {
	return p.TraceIds
}

func (p *GetTraceCombosByIdsArgs) GetAdjust() []Adjust {
	return p.Adjust
}
func (p *GetTraceCombosByIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceCombosByIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int64, 0, size)
	p.TraceIds = tSlice
	for i := 0; i < size; i++ {
		var _elem64 int64
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem64 = v
		}
		p.TraceIds = append(p.TraceIds, _elem64)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceCombosByIdsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]Adjust, 0, size)
	p.Adjust = tSlice
	for i := 0; i < size; i++ {
		var _elem65 Adjust
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Adjust(v)
			_elem65 = temp
		}
		p.Adjust = append(p.Adjust, _elem65)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceCombosByIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceCombosByIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceCombosByIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_ids", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_ids: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I64, len(p.TraceIds)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.TraceIds {
		if err := oprot.WriteI64(int64(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_ids: %s", p, err)
	}
	return err
}

func (p *GetTraceCombosByIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("adjust", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:adjust: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I32, len(p.Adjust)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Adjust {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:adjust: %s", p, err)
	}
	return err
}

func (p *GetTraceCombosByIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceCombosByIdsArgs(%+v)", *p)
}

type GetTraceCombosByIdsResult struct {
	Success []*TraceCombo   `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceCombosByIdsResult() *GetTraceCombosByIdsResult {
	return &GetTraceCombosByIdsResult{}
}

var GetTraceCombosByIdsResult_Success_DEFAULT []*TraceCombo

func (p *GetTraceCombosByIdsResult) GetSuccess() []*TraceCombo {
	return p.Success
}

var GetTraceCombosByIdsResult_Qe_DEFAULT *QueryException

func (p *GetTraceCombosByIdsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceCombosByIdsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceCombosByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceCombosByIdsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceCombosByIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceCombosByIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TraceCombo, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem66 := &TraceCombo{}
		if err := _elem66.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem66, err)
		}
		p.Success = append(p.Success, _elem66)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTraceCombosByIdsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceCombosByIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceCombosByIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceCombosByIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceCombosByIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceCombosByIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceCombosByIdsResult(%+v)", *p)
}

type GetServiceNamesArgs struct {
}

func NewGetServiceNamesArgs() *GetServiceNamesArgs {
	return &GetServiceNamesArgs{}
}

func (p *GetServiceNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetServiceNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getServiceNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetServiceNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetServiceNamesArgs(%+v)", *p)
}

type GetServiceNamesResult struct {
	Success map[string]bool `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetServiceNamesResult() *GetServiceNamesResult {
	return &GetServiceNamesResult{}
}

var GetServiceNamesResult_Success_DEFAULT map[string]bool

func (p *GetServiceNamesResult) GetSuccess() map[string]bool {
	return p.Success
}

var GetServiceNamesResult_Qe_DEFAULT *QueryException

func (p *GetServiceNamesResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetServiceNamesResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetServiceNamesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetServiceNamesResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetServiceNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetServiceNamesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[string]bool, size)
	p.Success = tSet
	for i := 0; i < size; i++ {
		var _elem67 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem67 = v
		}
		p.Success[_elem67] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *GetServiceNamesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetServiceNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getServiceNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetServiceNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.SET, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteSetBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing set begin: %s", err)
		}
		for v, _ := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteSetEnd(); err != nil {
			return fmt.Errorf("error writing set end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetServiceNamesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetServiceNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetServiceNamesResult(%+v)", *p)
}

type GetSpanNamesArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
}

func NewGetSpanNamesArgs() *GetSpanNamesArgs {
	return &GetSpanNamesArgs{}
}

func (p *GetSpanNamesArgs) GetServiceName() string {
	return p.ServiceName
}
func (p *GetSpanNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSpanNamesArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetSpanNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSpanNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSpanNamesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetSpanNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSpanNamesArgs(%+v)", *p)
}

type GetSpanNamesResult struct {
	Success map[string]bool `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetSpanNamesResult() *GetSpanNamesResult {
	return &GetSpanNamesResult{}
}

var GetSpanNamesResult_Success_DEFAULT map[string]bool

func (p *GetSpanNamesResult) GetSuccess() map[string]bool {
	return p.Success
}

var GetSpanNamesResult_Qe_DEFAULT *QueryException

func (p *GetSpanNamesResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetSpanNamesResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetSpanNamesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSpanNamesResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetSpanNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSpanNamesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[string]bool, size)
	p.Success = tSet
	for i := 0; i < size; i++ {
		var _elem68 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem68 = v
		}
		p.Success[_elem68] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *GetSpanNamesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetSpanNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSpanNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSpanNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.SET, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteSetBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing set begin: %s", err)
		}
		for v, _ := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteSetEnd(); err != nil {
			return fmt.Errorf("error writing set end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSpanNamesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetSpanNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSpanNamesResult(%+v)", *p)
}

type SetTraceTimeToLiveArgs struct {
	TraceId    int64 `thrift:"trace_id,1" json:"trace_id"`
	TtlSeconds int32 `thrift:"ttl_seconds,2" json:"ttl_seconds"`
}

func NewSetTraceTimeToLiveArgs() *SetTraceTimeToLiveArgs {
	return &SetTraceTimeToLiveArgs{}
}

func (p *SetTraceTimeToLiveArgs) GetTraceId() int64 {
	return p.TraceId
}

func (p *SetTraceTimeToLiveArgs) GetTtlSeconds() int32 {
	return p.TtlSeconds
}
func (p *SetTraceTimeToLiveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetTraceTimeToLiveArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TraceId = v
	}
	return nil
}

func (p *SetTraceTimeToLiveArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.TtlSeconds = v
	}
	return nil
}

func (p *SetTraceTimeToLiveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("setTraceTimeToLive_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetTraceTimeToLiveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_id", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_id: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TraceId)); err != nil {
		return fmt.Errorf("%T.trace_id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_id: %s", p, err)
	}
	return err
}

func (p *SetTraceTimeToLiveArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ttl_seconds", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:ttl_seconds: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TtlSeconds)); err != nil {
		return fmt.Errorf("%T.ttl_seconds (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:ttl_seconds: %s", p, err)
	}
	return err
}

func (p *SetTraceTimeToLiveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetTraceTimeToLiveArgs(%+v)", *p)
}

type SetTraceTimeToLiveResult struct {
	Qe *QueryException `thrift:"qe,1" json:"qe"`
}

func NewSetTraceTimeToLiveResult() *SetTraceTimeToLiveResult {
	return &SetTraceTimeToLiveResult{}
}

var SetTraceTimeToLiveResult_Qe_DEFAULT *QueryException

func (p *SetTraceTimeToLiveResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return SetTraceTimeToLiveResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *SetTraceTimeToLiveResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *SetTraceTimeToLiveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetTraceTimeToLiveResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *SetTraceTimeToLiveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("setTraceTimeToLive_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetTraceTimeToLiveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *SetTraceTimeToLiveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetTraceTimeToLiveResult(%+v)", *p)
}

type GetTraceTimeToLiveArgs struct {
	TraceId int64 `thrift:"trace_id,1" json:"trace_id"`
}

func NewGetTraceTimeToLiveArgs() *GetTraceTimeToLiveArgs {
	return &GetTraceTimeToLiveArgs{}
}

func (p *GetTraceTimeToLiveArgs) GetTraceId() int64 {
	return p.TraceId
}
func (p *GetTraceTimeToLiveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceTimeToLiveArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TraceId = v
	}
	return nil
}

func (p *GetTraceTimeToLiveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceTimeToLive_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceTimeToLiveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trace_id", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:trace_id: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TraceId)); err != nil {
		return fmt.Errorf("%T.trace_id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:trace_id: %s", p, err)
	}
	return err
}

func (p *GetTraceTimeToLiveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceTimeToLiveArgs(%+v)", *p)
}

type GetTraceTimeToLiveResult struct {
	Success *int32          `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTraceTimeToLiveResult() *GetTraceTimeToLiveResult {
	return &GetTraceTimeToLiveResult{}
}

var GetTraceTimeToLiveResult_Success_DEFAULT int32

func (p *GetTraceTimeToLiveResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return GetTraceTimeToLiveResult_Success_DEFAULT
	}
	return *p.Success
}

var GetTraceTimeToLiveResult_Qe_DEFAULT *QueryException

func (p *GetTraceTimeToLiveResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTraceTimeToLiveResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTraceTimeToLiveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTraceTimeToLiveResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTraceTimeToLiveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTraceTimeToLiveResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetTraceTimeToLiveResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTraceTimeToLiveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTraceTimeToLive_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTraceTimeToLiveResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceTimeToLiveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTraceTimeToLiveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTraceTimeToLiveResult(%+v)", *p)
}

type GetDataTimeToLiveArgs struct {
}

func NewGetDataTimeToLiveArgs() *GetDataTimeToLiveArgs {
	return &GetDataTimeToLiveArgs{}
}

func (p *GetDataTimeToLiveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDataTimeToLiveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDataTimeToLive_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDataTimeToLiveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDataTimeToLiveArgs(%+v)", *p)
}

type GetDataTimeToLiveResult struct {
	Success *int32          `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetDataTimeToLiveResult() *GetDataTimeToLiveResult {
	return &GetDataTimeToLiveResult{}
}

var GetDataTimeToLiveResult_Success_DEFAULT int32

func (p *GetDataTimeToLiveResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return GetDataTimeToLiveResult_Success_DEFAULT
	}
	return *p.Success
}

var GetDataTimeToLiveResult_Qe_DEFAULT *QueryException

func (p *GetDataTimeToLiveResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetDataTimeToLiveResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetDataTimeToLiveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetDataTimeToLiveResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetDataTimeToLiveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDataTimeToLiveResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetDataTimeToLiveResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetDataTimeToLiveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDataTimeToLive_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDataTimeToLiveResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetDataTimeToLiveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetDataTimeToLiveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDataTimeToLiveResult(%+v)", *p)
}

type GetDependenciesArgs struct {
	StartTime int64 `thrift:"start_time,1" json:"start_time"`
	EndTime   int64 `thrift:"end_time,2" json:"end_time"`
}

func NewGetDependenciesArgs() *GetDependenciesArgs {
	return &GetDependenciesArgs{}
}

func (p *GetDependenciesArgs) GetStartTime() int64 {
	return p.StartTime
}

func (p *GetDependenciesArgs) GetEndTime() int64 {
	return p.EndTime
}
func (p *GetDependenciesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDependenciesArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartTime = v
	}
	return nil
}

func (p *GetDependenciesArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndTime = v
	}
	return nil
}

func (p *GetDependenciesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDependencies_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDependenciesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_time", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_time: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.StartTime)); err != nil {
		return fmt.Errorf("%T.start_time (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_time: %s", p, err)
	}
	return err
}

func (p *GetDependenciesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_time", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_time: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.EndTime)); err != nil {
		return fmt.Errorf("%T.end_time (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_time: %s", p, err)
	}
	return err
}

func (p *GetDependenciesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDependenciesArgs(%+v)", *p)
}

type GetDependenciesResult struct {
	Success *zipkindependencies.Dependencies `thrift:"success,0" json:"success"`
	Qe      *QueryException                  `thrift:"qe,1" json:"qe"`
}

func NewGetDependenciesResult() *GetDependenciesResult {
	return &GetDependenciesResult{}
}

var GetDependenciesResult_Success_DEFAULT *zipkindependencies.Dependencies

func (p *GetDependenciesResult) GetSuccess() *zipkindependencies.Dependencies {
	if !p.IsSetSuccess() {
		return GetDependenciesResult_Success_DEFAULT
	}
	return p.Success
}

var GetDependenciesResult_Qe_DEFAULT *QueryException

func (p *GetDependenciesResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetDependenciesResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetDependenciesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetDependenciesResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetDependenciesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDependenciesResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &zipkindependencies.Dependencies{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetDependenciesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetDependenciesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getDependencies_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDependenciesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetDependenciesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetDependenciesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDependenciesResult(%+v)", *p)
}

type GetTopAnnotationsArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
}

func NewGetTopAnnotationsArgs() *GetTopAnnotationsArgs {
	return &GetTopAnnotationsArgs{}
}

func (p *GetTopAnnotationsArgs) GetServiceName() string {
	return p.ServiceName
}
func (p *GetTopAnnotationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopAnnotationsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetTopAnnotationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopAnnotations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopAnnotationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetTopAnnotationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopAnnotationsArgs(%+v)", *p)
}

type GetTopAnnotationsResult struct {
	Success []string        `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTopAnnotationsResult() *GetTopAnnotationsResult {
	return &GetTopAnnotationsResult{}
}

var GetTopAnnotationsResult_Success_DEFAULT []string

func (p *GetTopAnnotationsResult) GetSuccess() []string {
	return p.Success
}

var GetTopAnnotationsResult_Qe_DEFAULT *QueryException

func (p *GetTopAnnotationsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTopAnnotationsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTopAnnotationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTopAnnotationsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTopAnnotationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopAnnotationsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem69 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem69 = v
		}
		p.Success = append(p.Success, _elem69)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTopAnnotationsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTopAnnotationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopAnnotations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopAnnotationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTopAnnotationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTopAnnotationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopAnnotationsResult(%+v)", *p)
}

type GetTopKeyValueAnnotationsArgs struct {
	ServiceName string `thrift:"service_name,1" json:"service_name"`
}

func NewGetTopKeyValueAnnotationsArgs() *GetTopKeyValueAnnotationsArgs {
	return &GetTopKeyValueAnnotationsArgs{}
}

func (p *GetTopKeyValueAnnotationsArgs) GetServiceName() string {
	return p.ServiceName
}
func (p *GetTopKeyValueAnnotationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopKeyValueAnnotations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:service_name: %s", p, err)
	}
	return err
}

func (p *GetTopKeyValueAnnotationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopKeyValueAnnotationsArgs(%+v)", *p)
}

type GetTopKeyValueAnnotationsResult struct {
	Success []string        `thrift:"success,0" json:"success"`
	Qe      *QueryException `thrift:"qe,1" json:"qe"`
}

func NewGetTopKeyValueAnnotationsResult() *GetTopKeyValueAnnotationsResult {
	return &GetTopKeyValueAnnotationsResult{}
}

var GetTopKeyValueAnnotationsResult_Success_DEFAULT []string

func (p *GetTopKeyValueAnnotationsResult) GetSuccess() []string {
	return p.Success
}

var GetTopKeyValueAnnotationsResult_Qe_DEFAULT *QueryException

func (p *GetTopKeyValueAnnotationsResult) GetQe() *QueryException {
	if !p.IsSetQe() {
		return GetTopKeyValueAnnotationsResult_Qe_DEFAULT
	}
	return p.Qe
}
func (p *GetTopKeyValueAnnotationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTopKeyValueAnnotationsResult) IsSetQe() bool {
	return p.Qe != nil
}

func (p *GetTopKeyValueAnnotationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem70 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem70 = v
		}
		p.Success = append(p.Success, _elem70)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Qe = &QueryException{}
	if err := p.Qe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Qe, err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopKeyValueAnnotations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopKeyValueAnnotationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTopKeyValueAnnotationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetQe() {
		if err := oprot.WriteFieldBegin("qe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:qe: %s", p, err)
		}
		if err := p.Qe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Qe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:qe: %s", p, err)
		}
	}
	return err
}

func (p *GetTopKeyValueAnnotationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopKeyValueAnnotationsResult(%+v)", *p)
}

type GetSpanDurationsArgs struct {
	TimeStamp   int64  `thrift:"time_stamp,1" json:"time_stamp"`
	ServiceName string `thrift:"service_name,2" json:"service_name"`
	RpcName     string `thrift:"rpc_name,3" json:"rpc_name"`
}

func NewGetSpanDurationsArgs() *GetSpanDurationsArgs {
	return &GetSpanDurationsArgs{}
}

func (p *GetSpanDurationsArgs) GetTimeStamp() int64 {
	return p.TimeStamp
}

func (p *GetSpanDurationsArgs) GetServiceName() string {
	return p.ServiceName
}

func (p *GetSpanDurationsArgs) GetRpcName() string {
	return p.RpcName
}
func (p *GetSpanDurationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSpanDurationsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TimeStamp = v
	}
	return nil
}

func (p *GetSpanDurationsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetSpanDurationsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.RpcName = v
	}
	return nil
}

func (p *GetSpanDurationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSpanDurations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSpanDurationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("time_stamp", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:time_stamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TimeStamp)); err != nil {
		return fmt.Errorf("%T.time_stamp (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:time_stamp: %s", p, err)
	}
	return err
}

func (p *GetSpanDurationsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:service_name: %s", p, err)
	}
	return err
}

func (p *GetSpanDurationsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rpc_name", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:rpc_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.RpcName)); err != nil {
		return fmt.Errorf("%T.rpc_name (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:rpc_name: %s", p, err)
	}
	return err
}

func (p *GetSpanDurationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSpanDurationsArgs(%+v)", *p)
}

type GetSpanDurationsResult struct {
	Success map[string][]int64 `thrift:"success,0" json:"success"`
}

func NewGetSpanDurationsResult() *GetSpanDurationsResult {
	return &GetSpanDurationsResult{}
}

var GetSpanDurationsResult_Success_DEFAULT map[string][]int64

func (p *GetSpanDurationsResult) GetSuccess() map[string][]int64 {
	return p.Success
}
func (p *GetSpanDurationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSpanDurationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSpanDurationsResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][]int64, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key71 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key71 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([]int64, 0, size)
		_val72 := tSlice
		for i := 0; i < size; i++ {
			var _elem73 int64
			if v, err := iprot.ReadI64(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem73 = v
			}
			_val72 = append(_val72, _elem73)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Success[_key71] = _val72
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetSpanDurationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSpanDurations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSpanDurationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.I64, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteI64(int64(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSpanDurationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSpanDurationsResult(%+v)", *p)
}

type GetServiceNamesToTraceIdsArgs struct {
	TimeStamp   int64  `thrift:"time_stamp,1" json:"time_stamp"`
	ServiceName string `thrift:"service_name,2" json:"service_name"`
	RpcName     string `thrift:"rpc_name,3" json:"rpc_name"`
}

func NewGetServiceNamesToTraceIdsArgs() *GetServiceNamesToTraceIdsArgs {
	return &GetServiceNamesToTraceIdsArgs{}
}

func (p *GetServiceNamesToTraceIdsArgs) GetTimeStamp() int64 {
	return p.TimeStamp
}

func (p *GetServiceNamesToTraceIdsArgs) GetServiceName() string {
	return p.ServiceName
}

func (p *GetServiceNamesToTraceIdsArgs) GetRpcName() string {
	return p.RpcName
}
func (p *GetServiceNamesToTraceIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TimeStamp = v
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.ServiceName = v
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.RpcName = v
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getServiceNamesToTraceIds_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("time_stamp", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:time_stamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TimeStamp)); err != nil {
		return fmt.Errorf("%T.time_stamp (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:time_stamp: %s", p, err)
	}
	return err
}

func (p *GetServiceNamesToTraceIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("service_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:service_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ServiceName)); err != nil {
		return fmt.Errorf("%T.service_name (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:service_name: %s", p, err)
	}
	return err
}

func (p *GetServiceNamesToTraceIdsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rpc_name", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:rpc_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.RpcName)); err != nil {
		return fmt.Errorf("%T.rpc_name (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:rpc_name: %s", p, err)
	}
	return err
}

func (p *GetServiceNamesToTraceIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetServiceNamesToTraceIdsArgs(%+v)", *p)
}

type GetServiceNamesToTraceIdsResult struct {
	Success map[string][]int64 `thrift:"success,0" json:"success"`
}

func NewGetServiceNamesToTraceIdsResult() *GetServiceNamesToTraceIdsResult {
	return &GetServiceNamesToTraceIdsResult{}
}

var GetServiceNamesToTraceIdsResult_Success_DEFAULT map[string][]int64

func (p *GetServiceNamesToTraceIdsResult) GetSuccess() map[string][]int64 {
	return p.Success
}
func (p *GetServiceNamesToTraceIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetServiceNamesToTraceIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][]int64, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key74 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key74 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([]int64, 0, size)
		_val75 := tSlice
		for i := 0; i < size; i++ {
			var _elem76 int64
			if v, err := iprot.ReadI64(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem76 = v
			}
			_val75 = append(_val75, _elem76)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Success[_key74] = _val75
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getServiceNamesToTraceIds_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetServiceNamesToTraceIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.I64, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteI64(int64(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetServiceNamesToTraceIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetServiceNamesToTraceIdsResult(%+v)", *p)
}
