# this is a work in progress.
# it's doing proper cleanup and management of child processes
# use it with care, not all edge cases are covered.
#
# author @devrim

traverse = require 'traverse'
_        = require 'underscore'
fs       = require "fs"
hat      = require 'hat'
{exec,spawn,fork}   = require "child_process"
{EventEmitter} = require "events"

try
  fs.mkdirSync __dirname+"/.tmp/"
catch e
  # do nothing, probably dir is already there.

# guaranteed death.
process.on 'SIGTERM', ->
  console.log "going down"
  process.exit(0)


class Processes extends EventEmitter
  constructor:(options={})->
    {main} = options
    @list = {}
    @childProcessesContainerDir = __dirname+"/.tmp"
    if main
      previouschildProcessesContainerDir = @childProcessesContainerDir+"."+Date.now()
      fs.renameSync @childProcessesContainerDir, previouschildProcessesContainerDir
      fs.mkdirSync @childProcessesContainerDir
      exec "rm -rf #{previouschildProcessesContainerDir}",(err,stdout,stderr)->
        if err
          console.log "couldn't delete previous process tree at #{previouschildProcessesContainerDir}"
        else
          console.log "previous process tree is deleted."
  fork: (options,callback) ->
    {modulePath,name} = options
    if modulePath
      @run options
    else
      console.log "Error. can't fork without a module path. [#{name} is attempted]"

  run  : (options,callback) ->
    {name,modulePath,args,opts,restart,restartInterval,cmd,log,onExit,stdout,stderr,verbose} = options
    onExit ?= ->
    
    name            ?= Date.now()
    restartInterval ?= 1000
    verbose         ?= no

    if cmd
      cmdA = cmd.split(" ")
      cp = spawn cmdA[0],cmdA[1...]
    else if modulePath
      cp = fork modulePath,args,opts
    else
      return console.log "Error, no cmd or modulePath provided to processes."

    console.log "Started the process: #{name} with #{cp.pid}" if verbose
    @createPidFile cp.pid

    childObj = 
      name    : name
      process : cp
      pid     : cp.pid
      verbose : verbose

    childObj.cmd = cmd if cmd
    childObj.fork = {modulePath,args,options} if modulePath


    # console.log childObj

    @list[name] = childObj  
    cp.stdout.pipe stdout if stdout
    cp.stderr.pipe stderr if stderr

    cp.on 'exit',->
      console.log "#{name} did exit." if verbose
    cp.on 'close', () =>      
      console.log "#{name} did close." if verbose
      onExit cp.pid
      if restart is yes
        setTimeout =>
          @run options
        ,restartInterval
        console.log "Restarting the process in #{restartInterval} msecs." if verbose   
  

  createPidFile : (pid)->
    fs.writeFileSync "#{@childProcessesContainerDir}/#{process.pid}.#{pid}"

  get : (name)->
    @list[name].process

  fetchChildren : (parentPid,callback)->
    findChildren = (arr, pid) ->
      findChildrenRec = (pid,root=yes)->
        c={}
        pid = ""+pid
        i = -1
        arr.forEach (item)->
          [parent,child] = item.split(".")
          if parent is pid
            c[child] = findChildrenRec child,no
        return c

      arr = traverse(findChildrenRec pid).paths()
      arr.forEach (group) -> group.reverse()
      arr = _.sortBy arr,(a)-> a.length*-1
      return _.uniq _.flatten arr,yes

    fs.readdir @childProcessesContainerDir,(err,list)->
      if err
        callback err
      else
        callback null,findChildren list,parentPid

  killAllChildren : (parentPid, callback) ->
    @fetchChildren parentPid,(err,orderedKillList)->
      console.log "ordered kill list:"+orderedKillList
      unless err
        pidPair = []
        orderedKillList.forEach (pid)->
          console.log "killing children: #{pid}"
          try
            pidPair.push pid
            process.kill(pid*1)
            if pidPair.length is 2
              pidPair.reverse()
              deleteFile = pidPair.join(".")
              console.log "deleting"+deleteFile
              fs.unlinkSync deleteFile
              pidPair.shift()
          catch e
            console.log "child process #{pid} did not exist. not killed by me."
        callback null

  kill :(name,callback=->)->
    console.log "cant kill #{name}, couldn't find it." unless @list[name]
    pid = @list[name].pid
    console.log "killing parent: #{pid}"
    @killAllChildren pid,(err,res)->
      console.log "killing #{name} #{pid}"
      process.kill pid

module.exports = Processes