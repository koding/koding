module.exports = class Broker
  amqp = require 'amqp'
  DELIMITER = 'Î»'

  ###
  Quick option to declare a durable auto-delete exchange.
  ###
  createExchange = (connection, name, callback) ->
    options = {durable: true, autoDelete: true}
    connection.exchange name, options, callback

  ###
  Quick option to declare a durable exclusive queue.
  ###
  createQueue = (connection, name, callback) ->
    console.log 'create queue is called'
    options = {durable: true, exclusive: true}
    connection.queue name, options, callback

  subscribe = (connection, channel, event, listener) ->
    createQueue connection, '', (queue) ->
      queue.bind channel, event
      queue.on 'queueBindOk', ->
        result = queue.subscribe (payload) ->
          message = payload.data+""
          if 'string' is typeof message
            listener message
          else
            try 
              message = JSON.parse message
              listener message
            catch e
              listener message: 'Parse error!'

  constructor: (options) ->
    @options = options
    @eventMap = {}
    @connection = amqp.createConnection options
    @connection.on 'ready', => @readyState = 1
    @connection.setMaxListeners(0)
    @readyState = 0
    # @connection.on 'ready', callback if callback

  emit: (channel, event, payload, options) ->
    createExchange @connection, channel, (exchange) ->
      exchange.publish event, payload, options

  funnel:(exchangeName, queueName)->
    @ready =>
      createExchange @connection, exchangeName, (exchange)=>
        @connection.queue queueName, (queue)->
          queue.bind exchange, '#'

  ready:(listener)->
    if @readyState is 1
      listener()
    else
      @connection.on 'ready', -> listener()

  on: (channel, event, listener) ->
    # eventMap = @eventMap
    # key = channel+DELIMITER+event
    # return if eventMap[key]
    @ready =>
      unless channel in (@connection.exchanges or [])
        createExchange @connection, channel, =>
          subscribe(@connection, channel, event, listener)
      else
        subscribe(@connection, channel, event, listener)

    # createQueue @connection, '', (queue) ->
    #     queue.bind channel, event
    #     queue.on 'queueBindOk', ->
    #         queue.subscribe (payload) ->
    #             console.log payload
    #             listener payload.data
    #         .addCallback (ok) ->
    #             ctag = ok.consumerTag
    #             eventMap[key] = [queue, ctag]

  off: (channel, event, listener) ->
    key = channel+DELIMITER+event
    [queue, ctag] = @eventMap[key]
    queue.unsubscribe(ctag)
    queue.destroy()

  # Alias
  trigger: @::emit
  bind: @::on
  unbind: @::off