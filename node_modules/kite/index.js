var Kite, Pusher, Scrubber, Store, exec, express, log, nodePath, os, request, spawn, _ref, _ref2;
var __slice = Array.prototype.slice, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
os = require('os');
nodePath = require('path');
_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;
_ref2 = require('koding-dnode-protocol'), Scrubber = _ref2.Scrubber, Store = _ref2.Store;
Pusher = require('node-pusher');
request = require('request');
express = require('express');
log = console.log;
module.exports = Kite = (function() {
  function Kite(kiteName, api) {
    var _ref3;
    this.kiteName = kiteName;
    this.api = api;
    if (!api) {
      _ref3 = [kiteName, api], this.api = _ref3[0], this.kiteName = _ref3[1];
    }
    this.kiteName || (this.kiteName = 'unknown');
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.app = express.createServer();
    this.app.use(express.bodyParser());
    this.channels = {};
    this.requesters = {};
  }
  Kite.prototype.unscrubMessage = function(requesterId, scrubbed, callback) {
    var scrubber, unscrubbed;
    if (!((scrubbed.arguments != null) && (scrubbed.callbacks != null))) {
      return callback([scrubbed, function() {}]);
    } else {
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(scrubbed, __bind(function(callbackId) {
        if (!this.remoteStore.has(requesterId + callbackId)) {
          this.remoteStore.add(requesterId + callbackId, __bind(function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return this.request(unscrubbed[0].secretChannelId, callbackId, args);
          }, this));
        }
        return this.remoteStore.get(requesterId + callbackId);
      }, this));
      return callback(unscrubbed);
    }
  };
  Kite.prototype.startRequestHandler = function(config) {
    var cmd, hostname, joinedChannelsDir, kiteUri, logfile, port, protocol, requestHandler, requestHandlerPath;
    hostname = os.hostname();
    protocol = config.protocol || 'http://';
    port = config.port;
    hostname = os.hostname();
    kiteUri = "" + protocol + hostname + ":" + port + "/";
    logfile = config.requestHandler.logfile || '/tmp/kite-request-handler.log';
    joinedChannelsDir = config.requestHandler.joinedChannelsDir || '/tmp/joined-channels-file/';
    requestHandlerPath = config.requestHandler.path || nodePath.join(nodePath.dirname(module.filename), 'lib/request-handler');
    cmd = ["cd " + requestHandlerPath + " &&", 'ruby index.rb', '-k', config.pusher.key, '-s', config.pusher.secret, '-l', logfile, '-u', kiteUri, '-n', this.kiteName, '-j', joinedChannelsDir].join(' ');
    console.log(cmd);
    requestHandler = exec(cmd);
    requestHandler.stdout.on('data', function(data) {
      return log('DATA:', data);
    });
    requestHandler.stderr.on('data', function(data) {
      return log('ERROR:', data);
    });
    requestHandler.on('exit', __bind(function(code) {
      log("REQUEST HANDLER PROCESS EXITED WITH CODE " + code);
      return setTimeout((__bind(function() {
        return this.startRequestHandler(config);
      }, this)), 1000);
    }, this));
    return process.on('exit', function() {
      return requestHandler.kill();
    });
  };
  Kite.prototype.handleRequest = function(data, res, config) {
    var channels, requesterId, requesters, scrubbed;
    res.header('Content-type', 'text/javascript');
    channels = this.channels, requesters = this.requesters;
    try {
      scrubbed = JSON.parse(data.data);
      requesterId = data.username;
    } catch (e) {
      return res.send({
        error: 400
      });
    }
    return this.unscrubMessage(requesterId, scrubbed, __bind(function(unscrubbed) {
      var callback, callbackId, channel, kallback, secretChannelId, subscriberCount, method, withArgs, _base, _base2, _base3, _ref3, _ref4, _ref5;
      data = unscrubbed[0], callback = unscrubbed[1];
      method = data.method, withArgs = data.withArgs, secretChannelId = data.secretChannelId, subscriberCount = data.subscriberCount, callbackId = data.callbackId;
      withArgs || (withArgs = {});
      withArgs.username = requesterId;
      channel = "private-" + this.kiteName + "-" + requesterId;
      if (method !== '_disconnect' && !(requesters[requesterId] != null)) {
        if (typeof (_base = this.api)._connect === "function") {
          _base._connect({
            requesterId: requesterId
          });
        }
        if ((_ref3 = config.requestHandler) != null ? _ref3.isEnabled : void 0) {
          this.pusher.trigger("private-krh-" + this.kiteName, 'join', {
            channel: channel
          }).trigger(channel, 'changeTransport', {
            transport: 'mq'
          });
        }
        requesters[requesterId] = {};
      }
      switch (method) {
        case '_handleCallback':
          kallback = this.localStore.get(scrubbed.method);
          if (typeof kallback === "function") {
            kallback.apply(null, withArgs);
          }
          return res.send({
            result: 200
          });
        case '_disconnect':
          if (requesters[requesterId] != null) {
            Object.keys(requesters[requesterId]).forEach(function(channelId) {
              if (--channels[channelId] === 0) {
                return delete channels[channelId];
              }
            });
            if (typeof (_base2 = this.api)._disconnect === "function") {
              _base2._disconnect({
                requesterId: requesterId,
                channels: requesters[requesterId]
              });
            }
            if ((_ref4 = config.requestHandler) != null ? _ref4.isEnabled : void 0) {
              this.pusher.trigger("private-krh-" + this.kiteName, 'part', {
                channel: channel
              });
            }
            delete requesters[requesterId];
            return res.send({
              result: 200
            });
          } else {
            return res.send({
              error: 400
            });
          }
          break;
        case '_ping':
          return res.send({
            result: 200
          });
        default:
          if (this.api.propertyIsEnumerable(method) && 'function' === typeof this.api[method]) {
            if ((_ref5 = channels[secretChannelId]) == null) {
              channels[secretChannelId] = 0;
            }
            channels[secretChannelId] += 1;
            requesters[requesterId][secretChannelId] = true;
            withArgs.requesterId = requesterId;
            if (typeof (_base3 = this.api)[method] === "function") {
              _base3[method](withArgs, __bind(function(err, msg) {
                var scrubber;
                if (channels[secretChannelId] != null) {
                  scrubber = new Scrubber(this.localStore);
                  return scrubber.scrub([].slice.call(arguments), __bind(function() {
                    var out;
                    out = scrubber.toDnodeProtocol();
                    out.method = callback.id;
                    return this.pusher.trigger(secretChannelId, 'message', out);
                  }, this));
                }
              }, this));
            }
            return res.send({
              result: 200
            });
          } else {
            return res.send({
              error: 400
            });
          }
      }
    }, this));
  };
  Kite.prototype.handleRequests = function(config) {
    this.app.post('/', __bind(function(req, res) {
      return this.handleRequest(req.body, res, config);
    }, this));
    return this.app.get('/', __bind(function(req, res) {
      return this.handleRequest(req.query, res, config);
    }, this));
  };
  Kite.prototype.registerSelf = function() {
    var uri;
    uri = this.apiUri + '/kite/connect';
    console.log('Connecting to the API server:', uri);
    return request.get({
      uri: uri,
      qs: {
        data: JSON.stringify({
          kiteName: this.kiteName,
          uri: this.protocol + os.hostname() + ':' + this.port
        })
      }
    }, function(err, response, body) {
      return console.log('Received a response from the API server:', body);
    });
  };
  Kite.prototype.request = function(secretChannelId, callbackId, args) {
    var scrubber;
    scrubber = new Scrubber(this.localStore);
    return scrubber.scrub(args, __bind(function() {
      var out;
      out = scrubber.toDnodeProtocol();
      out.method = callbackId;
      return this.pusher.trigger(secretChannelId, 'message', out);
    }, this));
  };
  Kite.prototype.run = function(config) {
    var logPath, pidPath, port, protocol, _ref3;
    port = config.port, pidPath = config.pidPath, logPath = config.logPath, protocol = config.protocol, this.apiUri = config.apiUri;
    this.pusher = new Pusher(config.pusher);
    if (pidPath) {
      require("fs").writeFile(pidPath, "" + process.pid, function(err) {
        if (err != null) {
          return console.log("[WARN] Can't write pid to " + pidPath + ":  monit can't watch this process. err:" + err.message);
        }
      });
    }
    this.protocol = protocol || 'http://';
    this.port = port;
    this.app.listen(port);
    if ((_ref3 = config.requestHandler) != null ? _ref3.isEnabled : void 0) {
      this.startRequestHandler(config);
    }
    this.handleRequests(config);
    return this.registerSelf();
  };
  return Kite;
})();