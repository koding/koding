var Kite, Scrubber, Store, amqp, parse, serializableError, stringify, _ref,
  __slice = [].slice;

amqp = require('amqp');

_ref = require('koding-dnode-protocol'), Scrubber = _ref.Scrubber, Store = _ref.Store;

parse = JSON.parse, stringify = JSON.stringify;

Object.defineProperty(Object.prototype, 'throwError', {
  value: function(it) {
    throw it;
  }
});

serializableError = function(err) {
  return {
    message: err.message,
    stack: err.stack
  };
};

module.exports = Kite = (function() {

  function Kite(kiteName, api) {
    var _ref1;
    this.kiteName = kiteName;
    this.api = api;
    if (!api) {
      _ref1 = [kiteName, api], this.api = _ref1[0], this.kiteName = _ref1[1];
    }
    this.kiteName || (this.kiteName = 'unknown');
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.channels = {};
    this.requesters = {};
  }

  Kite.prototype.handleError = function(exchange, replyTo, callbackId, err) {
    if (callbackId == null) {
      callbackId = 'uncaughtException';
    }
    err = serializableError(err);
    return exchange.publish(replyTo, stringify({
      "arguments": [err],
      method: callbackId,
      callbacks: {}
    }), {
      contentType: 'application/json'
    });
  };

  Kite.prototype.handleRequest = function(message, kiteConfig, _arg) {
    var channels, deliveryInfo, exchange, exchangeName, headers, privateExchangeName, replyTo, requesterId, requesters, scrubbed, user,
      _this = this;
    headers = _arg.headers, deliveryInfo = _arg.deliveryInfo, exchange = _arg.exchange, user = _arg.user;
    replyTo = deliveryInfo.replyTo || 'reply-' + deliveryInfo.routingKey;
    exchangeName = deliveryInfo.exchange;
    channels = this.channels, requesters = this.requesters;
    try {
      scrubbed = parse(message.data);
      privateExchangeName = deliveryInfo.exchange.split('.');
      requesterId = user;
    } catch (err) {
      this.handleError(exchange, replyTo, null, err);
    }
    return this.unscrubMessage(exchange, replyTo, requesterId, scrubbed, function(unscrubbed) {
      var callback, data, method, withArgs, _base, _base1, _base2, _ref1, _ref2;
      data = unscrubbed[0], callback = unscrubbed[1];
      if ((_ref1 = data.withArgs) != null) {
        _ref1.username = requesterId;
      }
      method = data.method, withArgs = data.withArgs;
      withArgs || (withArgs = {});
      if (method !== '_disconnect' && !(requesters[requesterId] != null)) {
        if (typeof (_base = _this.api)._connect === "function") {
          _base._connect({
            requesterId: requesterId
          });
        }
        requesters[requesterId] = {};
      }
      switch (method) {
        case '_disconnect':
          if (requesters[requesterId] != null) {
            Object.keys(requesters[requesterId]).forEach(function(channelId) {
              if (--channels[channelId] === 0) {
                return delete channels[channelId];
              }
            });
            if (typeof (_base1 = _this.api)._disconnect === "function") {
              _base1._disconnect({
                requesterId: requesterId,
                channels: requesters[requesterId]
              });
            }
            delete requesters[requesterId];
            return _this.handleResponse(exchange, replyTo, callback.id, {
              connectionCount: channels[channelId]
            });
          } else {
            return _this.handleError(exchange, replyTo, callback.id, {
              message: "Disconnect error: " + requesterId
            });
          }
          break;
        case '_ping':
          return _this.handleResponse(replyTo, callback.id, 1);
        default:
          if (_this.api.propertyIsEnumerable(method) && 'function' === typeof _this.api[method]) {
            if ((_ref2 = channels[exchangeName]) == null) {
              channels[exchangeName] = 0;
            }
            channels[exchangeName] += 1;
            requesters[requesterId][exchangeName] = true;
            withArgs.requesterId = requesterId;
            return typeof (_base2 = _this.api)[method] === "function" ? _base2[method](withArgs, function(err, msg) {
              if (channels[exchangeName] != null) {
                return _this.handleResponse(exchange, replyTo, callback.id, [].slice.call(arguments));
              }
            }) : void 0;
          } else if (callback = _this.localStore.get(scrubbed.method)) {
            return callback.apply(null, unscrubbed);
          } else {
            return _this.handleError(exchange, replyTo, callback != null ? callback.id : void 0, {
              message: "No such method! " + method
            });
          }
      }
    });
  };

  Kite.prototype.unscrubMessage = function(exchange, replyTo, requesterId, scrubbed, callback) {
    var scrubber, unscrubbed,
      _this = this;
    if (!((scrubbed["arguments"] != null) && (scrubbed.callbacks != null))) {
      return callback([scrubbed, function() {}]);
    } else {
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(scrubbed, function(callbackId) {
        if (!_this.remoteStore.has(requesterId + callbackId)) {
          _this.remoteStore.add(requesterId + callbackId, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return _this.handleResponse(exchange, replyTo, callbackId, args);
          });
        }
        return _this.remoteStore.get(requesterId + callbackId);
      });
      return callback(unscrubbed);
    }
  };

  Kite.prototype.handleResponse = function(exchange, replyTo, callbackId, args) {
    var scrubber,
      _this = this;
    scrubber = new Scrubber(this.localStore);
    return scrubber.scrub(args, function() {
      var out;
      out = scrubber.toDnodeProtocol();
      out.method = callbackId;
      return exchange.publish(replyTo, stringify(out));
    });
  };

  Kite.prototype.getQueueName = function() {
    return "kite-" + this.kiteName;
  };

  Kite.prototype.getExchangeName = function() {
    return "private-" + (this.getQueueName());
  };

  Kite.prototype.getExchangeOptions = function() {
    return {
      type: 'topic',
      autoDelete: true,
      durable: true
    };
  };

  Kite.prototype.join = function(_arg, config) {
    var queue, user,
      _this = this;
    user = _arg.user, queue = _arg.queue;
    return this.connection.exchange(queue, {
      durable: true,
      autoDelete: true
    }, function(exchange) {
      return _this.connection.queue(queue, function(queueOb) {
        return queueOb.subscribe(function(message, headers, deliveryInfo) {
          return _this.handleRequest(message, config, {
            headers: headers,
            deliveryInfo: deliveryInfo,
            exchange: exchange,
            user: user
          });
        });
      });
    });
  };

  Kite.prototype.registerSelf = function(config) {
    var host, options, password, port, protocol, username, vhost, _ref1,
      _this = this;
    _ref1 = config.amqp, host = _ref1.host, port = _ref1.port, protocol = _ref1.protocol, username = _ref1.username, password = _ref1.password, vhost = _ref1.vhost;
    if (port == null) {
      port = 5672;
    }
    if (protocol == null) {
      protocol = 'amqp:';
    }
    options = {
      host: host,
      port: port,
      protocol: protocol,
      vhost: vhost
    };
    if (username != null) {
      options.login = username;
    }
    if (password != null) {
      options.password = password;
    }
    if (vhost != null) {
      options.vhost = vhost;
    }
    this.connection = amqp.createConnection(options);
    return this.connection.on('ready', function() {
      return _this.connection.exchange(_this.getExchangeName(), _this.getExchangeOptions(), function(exchange) {
        return _this.connection.queue(_this.getQueueName(), function(queue) {
          queue.bind(exchange, 'join');
          return queue.on('queueBindOk', function() {
            return queue.subscribe(function(message, headers, deliveryInfo) {
              return _this.join(message, config);
            });
          });
        });
      });
    });
  };

  Kite.prototype.writePid = function(pidPath) {
    if (pidPath) {
      return require("fs").writeFile(pidPath, "" + process.pid, function(err) {
        if (err != null) {
          return console.log("[WARN] Can't write pid to " + pidPath + ":  monit can't watch this process. err:" + err.message);
        }
      });
    }
  };

  Kite.prototype.run = function(config) {
    var host, logPath, password, pidPath, username;
    pidPath = config.pidPath, logPath = config.logPath, host = config.host, username = config.username, password = config.password, this.apiUri = config.apiUri;
    this.writePid(pidPath);
    return this.registerSelf(config);
  };

  return Kite;

})();
