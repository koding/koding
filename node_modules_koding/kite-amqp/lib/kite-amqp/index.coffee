amqp = require 'amqp'
{Scrubber, Store} = require 'koding-dnode-protocol'
{parse, stringify} = JSON
Object.defineProperty Object::, 'throwError', value:(it)-> throw it

serializableError =(err)->
  message  : err.message
  stack    : err.stack

module.exports = class Kite
  
  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}
    @requesters = {}
  
  handleError:(exchange, replyTo, callbackId='uncaughtException', err)->
    err = serializableError(err)
    exchange.publish replyTo, stringify(
      arguments : [err]
      method    : callbackId
      callbacks : {}
    ),{
      contentType: 'application/json'
    }

  handleRequest:(message, kiteConfig, {headers, deliveryInfo, exchange, user})->
    replyTo = deliveryInfo.replyTo or 'reply-'+deliveryInfo.routingKey
    exchangeName = deliveryInfo.exchange
    {channels, requesters} = @
    try
      scrubbed = parse message.data
      privateExchangeName = deliveryInfo.exchange.split('.')
      requesterId = user #privateExchangeName[privateExchangeName.length-2]
    catch err then @handleError exchange, replyTo, null, err
    @unscrubMessage exchange, replyTo, requesterId, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      data.withArgs?.username = requesterId
      {method, withArgs} = data
      withArgs or= {}
      if method isnt '_disconnect' and not requesters[requesterId]?
        @api._connect? {requesterId}
        requesters[requesterId] = {}
      switch method
        when '_disconnect'
          if requesters[requesterId]?
            Object.keys(requesters[requesterId]).forEach (channelId)->
              delete channels[channelId] if --channels[channelId] is 0
            @api._disconnect? {
              requesterId
              channels: requesters[requesterId]
            }
            delete requesters[requesterId]
            @handleResponse exchange, replyTo, callback.id, {
              connectionCount: channels[channelId]
            }
          else
            @handleError exchange, replyTo, callback.id, {
              message: "Disconnect error: #{requesterId}"
            }
        when '_ping' then @handleResponse replyTo, callback.id, 1
        else
          if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
            channels[exchangeName] ?= 0
            channels[exchangeName] += 1
            requesters[requesterId][exchangeName] = yes
            withArgs.requesterId = requesterId
            @api[method]? withArgs, (err, msg)=>
              if channels[exchangeName]?
                @handleResponse exchange, replyTo, callback.id,
                  [].slice.call(arguments)
          else if callback = @localStore.get(scrubbed.method)
            callback.apply null, unscrubbed
          else
            @handleError exchange, replyTo, callback?.id, {
              message: "No such method! #{method}"
            }
  
  unscrubMessage:(exchange, replyTo, requesterId, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(requesterId+callbackId)
          @remoteStore.add requesterId+callbackId, (args...)=>
            @handleResponse exchange, replyTo, callbackId, args
        @remoteStore.get requesterId+callbackId
      callback unscrubbed
  
  handleResponse:(exchange, replyTo, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      out.pid = process.pid
      exchange.publish replyTo, stringify(out)
  
  getQueueName:-> "kite-#{@kiteName}"
  
  getExchangeName:-> "private-#{@getQueueName()}"
  
  getExchangeOptions:->
    type        : 'topic'
    autoDelete  : yes
    durable     : yes
  
  join:({user, queue}, config)->
    @connection.exchange queue, {durable:yes, autoDelete:yes}, (exchange)=>
      @connection.queue queue, (queueOb)=>
        queueOb.subscribe (message, headers, deliveryInfo)=>
          @handleRequest message, config, {headers, deliveryInfo, exchange, user}

  registerSelf:(config)->
    {host, port, protocol, username, password, vhost} = config.amqp
    port      ?= 5672
    protocol  ?= 'amqp:'
    options   = {host, port, protocol, vhost}
    # SASL authentication credentials (if any) for connecting to RabbitMQ backend:
    options.login = username if username?
    options.password = password if password?
    options.vhost = vhost if vhost?
    @connection = amqp.createConnection options
    @connection.on 'ready', =>
      @connection.exchange @getExchangeName(), @getExchangeOptions(), (exchange)=>
        @connection.queue @getQueueName(), (queue)=>
          queue.bind exchange, 'join'
          queue.on 'queueBindOk', =>
            queue.subscribe (message, headers, deliveryInfo)=>
              @join message, config
              #@handleRequest message, config, {headers, deliveryInfo}
      
  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
  
  run:(config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf config
