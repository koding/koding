module.exports = class Request

  models = require './models'

  constructor: (apiKey, loggedRequests) ->
    return new Request apiKey, loggedRequests  unless this instanceof Request
    @apiKey = apiKey
    @loggedRequests = loggedRequests

  POST: (operation, data, paymentMethodId, httpOptions, callback) =>
    [callback, httpOptions] = [httpOptions, callback]  unless callback

    @request {
      method: 'POST'
      operation
      httpOptions
      data
      paymentMethodId
    }, callback

  PUT: (operation, data, httpOptions, callback) =>
    [callback, httpOptions] = [httpOptions, callback]  unless callback

    @request {
      method: 'PUT'
      operation
      httpOptions
      data
    }, callback

  DEL: (operation, httpOptions, callback) =>
    [callback, httpOptions] = [httpOptions, callback]  unless callback

    @request {
      method: 'DELETE'
      operation
      httpOptions
      data: ''
    }, callback

  # GET request.
  # If there are multiple pages, this method requests all pages.
  # Returns list of XML/JS objects, not a single XML/JS object!
  # TODO: support buffering, return pages separately
  GET: (operation, httpOptions, callback) =>
    [callback, httpOptions] = [httpOptions, callback]  unless callback

    if operation.indexOf('per_page') is -1
      operation += "#{if operation.indexOf('?') > -1 then '&' else '?'}per_page=50"

    # Collect all GET responses before calling CB
    allData = []
    collect = (err, result, nextUrl) =>
      return callback err  if err

      allData.push result

      if nextUrl
        @request 'GET', nextUrl, '', collect
      else
        callback null, allData

    @request {
      method: 'GET'
      operation
      data: ''
      httpOptions
    }, collect

  # This method makes a request to Recurly. If the reponse is chunked,
  # it waits for the last chunk and returns output as JS object.
  request: ({ method, operation, httpOptions, data, paymentMethodId }, callback) ->

    log4js  = require 'log4js'
    logger  = log4js.getLogger('recurly')

    log4js.configure {
      appenders: [
        { type: 'console' }
        { type: 'file', filename: 'logs/recurly.log', category: 'recurly' }
        { type: "log4js-node-syslog", tag : "recurly", facility: "local0", hostname: "localhost", port: 514 }
      ]
    }

    logHelper = (type, {paymentMethodId, data, operation}) =>
      if (new RegExp(@loggedRequests)).test operation
        paymentMethodInfo = if paymentMethodId then "PaymentMethodId: #{paymentMethodId}\n" else ""
        logger[type] "\n#{paymentMethodInfo}Operation: #{operation} \nData: #{data}"

    https  = require 'https'
    xml2js = require 'xml2js'

    options =
      host     : 'api.recurly.com'
      port     : 443
      path     : "/v2/#{ operation }"
      method   : method
      auth     : "#{ @apiKey }:"
      headers  :
        Accept           : httpOptions?.accept ? 'application/xml'
        'Content-Length' : Buffer.byteLength data, 'utf8'

    if data.length > 0
      options.headers['Content-Type'] = 'application/xml; charset=UTF-8'

    console.time 'Recurly API request'
    logHelper "info", {paymentMethodId, operation, data}

    req = https.request options, (res)->
      res.setEncoding 'utf8'
      body = ''

      res.on 'data', (chunk)-> body += chunk
      res.on 'end',  ->
        return callback null, {}  unless body.length > 0

        console.timeEnd 'Recurly API request'

        # Parse XML and build JS object, or list of errors.
        xml2js.parseString body, (err, result)=>
          if err
            callback [new models.Error 'xml', 'Invalid XML']
            logHelper "error",{paymentMethodId, operation, data: err}
          else if result.error
            callback [new models.Error result.error.symbol[0], result.error.description[0]._]
            logHelper "error", {paymentMethodId, operation, data: result.error}
          else if result.errors
            # See https://docs.recurly.com/api/basics/validation-errors for XML format
            errors = []
            for err1 in result.errors.error
              if err1.$
                errors.push new models.Error err1.$.symbol, err1._, err1.$.field
              else
                errors.push new models.Error err1, err1
            callback errors
            logHelper "error", {paymentMethodId, operation, data: result.errors}
          else
            # Find next page's URL if necessary
            nextUrl = parseNextUrl res  if res.headers.link
            callback null, result, nextUrl
            logHelper "info", {paymentMethodId, operation, data: JSON.stringify(result)}

    req.on 'error', (e)->
      callback [new models.Error 'connection', 'Unable to connect to payment backend.']

    req.end(data, 'utf8')
