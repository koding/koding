
{argv}   = require 'optimist'
KONFIG   = require('koding-config-manager').load("main.#{argv.c}")

module.exports = class Recurly

  models = require './models'
  {loggedRequests, apiKey} = KONFIG.recurly
  { GET, POST, PUT, DEL } = (require './request') apiKey, loggedRequests

  summarizeErrors = (errors) ->
    billing = 0
    for e in errors
      if e.field.indexOf('subscription.account.billing_info') > -1 and ++billing > 2
        return new models.Error 'billing', 'Credit card information required.'

  # If requested list of records are longer than 50 items, recurly
  # paginates them. This method gets the URL path of next page.
  parseNextUrl = (res) ->
    links = {}
    for link in res.headers.link.split(', ')
      linkData = link.split('; ')
      rel = linkData[1].substring(5, linkData[1].length - 1)
      url = linkData[0].substring(1, linkData[0].length - 1)
      links[rel] = url.substring(url.indexOf('v2') + 3)
    return links


  #
  # concrete API methods
  #

  #
  # ACCOUNTS
  # See https://docs.recurly.com/api/accounts for XML format
  #

  @fetchAccountDetailsByPaymentMethodId = (paymentMethodId, callback) ->
    GET "accounts/#{paymentMethodId}", (err, res) =>
      return callback err  if err
      @fetchPaymentMethodById paymentMethodId, (err, billing) ->
        return callback err  if err
        callback null, new models.Account res[0]?.account, billing

  @setAccountDetailsByPaymentMethodId = (paymentMethodId, data, callback) ->

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <account>
        <account_code>#{paymentMethodId}</account_code>
        <username>#{data.username}</username>
        <email>#{data.email}</email>
        <first_name>#{data.firstName}</first_name>
        <last_name>#{data.lastName}</last_name>
      </account>
      """

    @fetchAccountDetailsByPaymentMethodId paymentMethodId, (err, account) ->
      if err or not account?.username
        POST 'accounts', xml, paymentMethodId, callback
      else
        PUT "accounts/#{paymentMethodId}", xml, callback

  @deleteAccount = (paymentMethodId, callback) ->
    DEL "accounts/#{paymentMethodId}", callback

  #
  # ADJUSTMENTS (ONE-TIME CHARGE/CREDIT TO SUBSCRIPTION)
  # See https://docs.recurly.com/api/invoices for XML format
  #

  @fetchAdjustments = (paymentMethodId, type, state, callback) ->
    [callback, state] = [state, callback]  unless callback
    [callback, type]  = [type, callback]   unless callback
    type  or= 'credits and charges'
    state or= 'active'

    url = "accounts/#{paymentMethodId}/adjustments?type=#{type}&state=#{state}"

    GET url, (err, res) ->
      return callback err  if err

      adjs = []
      for page in res
        adjs.push new models.Adjustment a  for a in page.adjustments?.adjustment

      callback null, adjs

  @fetchCharged = (paymentMethodId, callback) ->
    @fetchAdjustments paymentMethodId, 'charge', 'invoiced', callback

  @fetchPendingCharges = (paymentMethodId, callback) ->
    @fetchAdjustments paymentMethodId, 'charge', 'pending', callback

  @fetchCredited = (paymentMethodId, callback) ->
    @fetchAdjustments paymentMethodId, 'credit', 'invoiced', callback

  @fetchPendingCredits = (paymentMethodId, callback) ->
    @fetchAdjustments paymentMethodId, 'credit', 'pending', callback

  @createAdjustment = (paymentMethodId, data, callback) ->
    xml =
      """
      <adjustment>
        <description>#{data.description}</description>
        <unit_amount_in_cents>#{data.amount}</unit_amount_in_cents>
        <currency>USD</currency>
        <quantity>1</quantity>
        <accounting_code>#{data.accountingCode}</accounting_code>
      </adjustment>
      """

    POST "accounts/#{paymentMethodId}/adjustments", xml, paymentMethodId, (err, res) ->
      callback err, unless err then new models.Adjustment res.adjustment

  @createCharge = @createAdjustment

  @createRefund = (paymentMethodId, data, callback) ->
    data.amount = "#{-data.amount}"
    data.description ?= "Refund"
    @createAdjustment paymentMethodId, data, callback

  #
  # INVOICES
  # See https://docs.recurly.com/api/invoices for XML format
  #

  @fetchInvoices = (paymentMethodId, callback) ->
    GET "accounts/#{paymentMethodId}/invoices", (err, res) ->
      return callback err  if err

      invs = []
      for page in res
        invs.push new models.Invoice i  for i in page.invocies?.invoice

      callback null, invs

  # charge amount from pending one-time adjustments (carge/credit) to subscription
  # if not manually charged with this method, those will be automatically charged
  # on subscription's renewal (typically monthly)
  @chargePending = (paymentMethodId, callback) ->
    POST "accounts/#{paymentMethodId}/invoices", '', paymentMethodId, (err, res) ->
      callback err, unless err then new models.Transaction res.transaction

  #
  # PAYMENT METHODS
  # See https://docs.recurly.com/api/accounts for XML format
  #

  @fetchPaymentMethodById = (paymentMethodId, callback) ->
    GET "accounts/#{paymentMethodId}/billing_info", (err, res) ->
      return callback err  if err?
      paymentMethod = res[0]?.billing_info
      callback err,
        if paymentMethod
        then new models.PaymentMethod paymentMethod
        else {}

  makeTag = (field, tagName = field) ->
    if @[field]? then "<#{ tagName }>#{ @[field] }</#{ tagName }>" else ''

  @setPaymentMethodById = (paymentMethodId, data, callback) ->
    # Remove credit card number if it's not updated
    if (data.cardNumber?.indexOf '*') > -1 or data.cardCV?.cardCV is '***'
      delete data.cardNumber
      delete data.cardCV

    tag = makeTag.bind data

    # See https://docs.recurly.com/api/account for XML format
    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <billing_info>
        #{tag 'cardNumber', 'number'}
        #{tag 'cardCV', 'verification_value'}
        #{tag 'cardMonth', 'month'}
        #{tag 'cardYear', 'year'}
        #{tag 'company'}
        #{tag 'cardFirstName', 'first_name'}
        #{tag 'cardLastName', 'last_name'}
        #{tag 'cardAddress1', 'address1'}
        #{tag 'cardCity', 'city'}
        #{tag 'cardState', 'state'}
        #{tag 'cardCountry', 'country'}
        #{tag 'cardZipcode', 'zip'}
        #{tag 'phone'}
        #{tag 'vatNumber', 'vat_number'}
        #{tag 'ipAddress', 'ip_address'}
      </billing_info>
      """

    PUT "accounts/#{paymentMethodId}/billing_info", xml, callback

  #
  # PLANS
  # See https://docs.recurly.com/api/plans for documentation
  #

  @fetchPlans = (callback) ->
    GET 'plans', (err, res) ->
      return callback err  if err

      plans = []
      for page in res when page.plans?.plan
        plans.push new models.Plan p  for p in page.plans.plan

      callback null, plans

  @fetchPlan = (data, callback) ->
    GET "plans/#{data.planCode}", (err, res) ->
      return callback err  if err

      if res[0]?.plan
        callback null, new models.Plan res[0].plan
      else
        callback new models.Error 'plan', 'Requested plan not found'

  @createPlan = (data, callback) ->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <plan_code>#{data.planCode}</plan_code>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeAmount, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    POST 'plans', xml, null, (err, res) ->
      callback err, unless err then new models.Plan res.plan

  @updatePlan = (data, callback) ->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeAmount, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    PUT "plans/#{data.planCode}", xml, (err, res) ->
      callback err, unless err then new models.Plan res.plan

  @deletePlan = (data, callback) ->
    DEL "plans/#{data.planCode}", callback

  #
  # SUBSCRIPTIONS
  # See https://docs.recurly.com/api/subscriptions for documentation
  #

  @fetchSubscriptions = (paymentMethodId, callback) ->
    GET "accounts/#{paymentMethodId}/subscriptions", (err, res) ->
      return callback err  if err

      subs = res.map (page) ->
        new models.Subscription s  for s in page.subscriptions

      callback null, subs

  @fetchSubscription = (paymentMethodId, data, callback) ->
    GET "subscriptions/#{data.uuid}", (err, res) ->
      return callback err  if err

      if res[0]?.subscription
        callback null, new models.Subscription res[0].subscription
      else
        callback new models.Error 'subscription', 'Requested subscription not found'

  @createSubscription = (paymentMethodId, data, callback) ->
    data.couponCode ?= ""
    data.quantity   ?= 1

    tag = makeTag.bind data

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <plan_code>#{data.planCode}</plan_code>
        #{tag 'couponCode', 'coupon_code'}
        #{tag 'feeAmount', 'unit_amount_in_cents'}
        <currency>USD</currency>
        #{tag 'quantity'}
        #{tag 'startsAt', 'starts_at'}
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </subscription>
      """

    POST 'subscriptions', xml, paymentMethodId, (err, res) ->
      callback err, unless err then new models.Subscription res.subscription

  @updateSubscription = (data, callback) ->
    data.quantity ?= 1
    timeframe      = 'now'

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <timeframe>#{timeframe}</timeframe>
        <plan_code>#{data.plan}</plan_code>
        <quantity>#{data.quantity}</quantity>
      </subscription>
      """

    PUT "subscriptions/#{data.uuid}", xml, (err, res) ->
      callback err, unless err then new models.Subscription res.subscription

  @terminateSubscription = (data, callback) ->
    data.refund ?= 'none'

    PUT "subscriptions/#{data.uuid}/terminate?refund=#{data.refund}", '', (err, res)->
      callback err, unless err then new models.Subscription res.subscription

  @cancelSubscription = (data, callback) ->
    PUT "subscriptions/#{data.uuid}/cancel", '', (err, res) ->
      callback err, unless err then new models.Subscription res.subscription

  @reactivateSubscription = (data, callback) ->
    PUT "subscriptions/#{data.uuid}/reactivate", '', (err, res) ->
      callback err, unless err then new models.Subscription res.subscription

  #
  # TRANSACTIONS
  # See https://docs.recurly.com/api/transactions for documentation
  #

  @fetchTransactions = (paymentMethodId, callback) ->
    GET "accounts/#{paymentMethodId}/transactions", (err, res) ->
      return callback err  if err

      trans = []
      for page in res
        trans.push new models.Transaction t  for t in page.transactions?.transaction

      callback null, trans

  @createTransaction = (paymentMethodId, data, callback) ->
    xml =
      """
      <transaction>
        <description>#{data.description}</description>
        <amount_in_cents>#{data.amount}</amount_in_cents>
        <currency>USD</currency>
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </transaction>
      """

    POST 'transactions', xml, paymentMethodId, (err, res) ->
      callback err, unless err then new models.Transaction res.transaction

  @deleteTransaction = (paymentMethodId, data, callback) ->
    DEL "transactions/#{data.uuid}?amount_in_cents=##{data.amount}", callback

  #
  # COUPONS
  # See https://docs.recurly.com/api/coupons for documentation
  #

  @fetchCoupon = (couponCode, callback) ->
    GET "coupons/#{couponCode}", (err, res) ->
      return callback err  if err or res.length < 1
      callback null, new models.Coupon res[0]
