{Base, Model, ObjectId} = require 'bongo'

module.exports = class Relationship extends Model

  {Base, dash} = require 'bongo'

  @share()

  @set
    feedable:             yes
    broadcastable:        no
    sharedMethods:
      static:             ['within']
    schema:
      sourceName:         String
      abstractSourceName: String
      sourceId:           ObjectId
      targetName:         String
      abstractTargetName: String
      targetId:           ObjectId
      as:                 String
      data:               Object
      timestamp:
        type:             Date
        default:          -> new Date

  @getDeleteHelper =(selector, orientation, callback)->
    -> Relationship.all selector, (err, rels)->
      if err
        callback err
      else
        queue = []
        rels.forEach (rel)->
          queue.push ->
            constructor = Base.constructors[rel.getAt orientation+'Name']
            constructor.remove _id: rel.getAt(orientation+'Id'), -> queue.fin()
        dash queue, callback

  @within =(sourceIds, options, callback)->
    [callback, options] = [options, callback] unless callback
    options or= {}
    {as} = options
    delete options.as

    shared = $in: Object.keys(Base.sharedConstructors)

    selector = {
      sourceId:
        $in: sourceIds.map (id)->
          if 'string' is typeof id then ObjectId(id)
          else id
      $or: [
        {targetName: shared}
        {sourceName: shared}
      ]
    }

    selector.as = as if as?

    Relationship.some selector, options, callback

  flag:(prop, bool=yes)->
    flag = {}
    flag["data.#{prop}"] = bool
    @update $set: flag

  unflag:(prop)->
    @flag prop, no

  archive:-> #TODO: implement Archiver

  fetchOther =(name, _id, callback)->
    unless name and _id
      callback new Error "Couldn't resolve relation."
    else
      constructor = Base.constructors[name]
      if constructor?.one?
        constructor.one {_id}, callback

  fetchSource:(callback)->
    fetchOther @sourceName, @sourceId, callback

  fetchTarget:(callback)->
    fetchOther @targetName, @targetId, callback

  fetchTeaser:(callback)->
    sourceConstructor = Base.constructors[@sourceName]
    targetConstructor = Base.constructors[@targetName]
    unless sourceConstructor or targetConstructor
      callback new Error 'Invalid relationship!'
    else
      sourceConstructor.one _id: @sourceId, (err, @source)=>
        if err
          callback err
        else
          targetConstructor.one _id: @targetId, (err, @target)=>
            if err
              callback err
            else
              callback null, @