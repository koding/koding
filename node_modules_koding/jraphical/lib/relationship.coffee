{ Base, Model, ObjectId } = require 'bongo'

module.exports = class Relationship extends Model

  { Base, dash } = require 'bongo'

  @share()

  #TODO: implement data slugs

  @set
    softDelete:           yes
    feedable:             yes
    broadcastable:        no
    indexes:
      sourceName:         'sparse'
      sourceId:           'sparse'
      targetName:         'sparse'
      targetId:           'sparse'
      as:                 'sparse'
      timestamp:          'sparse'
    schema:
      sourceName:         String
      abstractSourceName: String
      sourceId:           ObjectId
      # sourceSlug:         String
      targetName:         String
      abstractTargetName: String
      targetId:           ObjectId
      # targetSlug:         String
      as:                 String
      data:
        type:             Object
        default:          -> {}
      timestamp:
        type:             Date
        default:          -> new Date
    sharedEvents :
      instance   : [ ]
      static     : [ ]

  @getDeleteHelper = (selector, orientation, callback) ->
    -> Relationship.all selector, (err, rels) ->
      if err
        callback err
      else
        queue = []
        rels.forEach (rel) ->
          queue.push ->
            constructor = Base.constructors[rel.getAt orientation + 'Name']
            constructor.remove { _id: rel.getAt(orientation + 'Id') }, -> queue.fin()
        dash queue, callback

  @within = (sourceIds, options, callback) ->
    [callback, options] = [options, callback] unless callback
    options or= {}
    { as } = options
    delete options.as

    shared = { $in: Object.keys(Base.sharedConstructors) }

    selector = {
      sourceId:
        $in: sourceIds.map (id) ->
          if 'string' is typeof id then ObjectId(id)
          else id
      $or: [
        { targetName: shared }
        { sourceName: shared }
      ]
    }

    selector.as = as if as?

    Relationship.some selector, options, callback

  flag:(prop, bool = yes) ->
    flag = {}
    flag["data.#{prop}"] = bool
    @update { $set: flag }

  unflag:(prop) ->
    @flag prop, no

  archive: -> #TODO: implement Archiver

  fetchOther = (name, _id, callback) ->
    unless name and _id
      callback new Error "Couldn't resolve relation."
    else
      constructor = Base.constructors[name]
      if constructor?.one?
        constructor.one { _id }, callback

  fetchSource:(callback) ->
    fetchOther @sourceName, @sourceId, callback

  fetchTarget:(callback) ->
    fetchOther @targetName, @targetId, callback

  fetchTeaser:(callback) ->
    sourceConstructor = Base.constructors[@sourceName]
    targetConstructor = Base.constructors[@targetName]
    unless sourceConstructor or targetConstructor
      callback new Error 'Invalid relationship!'
    else
      sourceConstructor.one { _id: @sourceId }, (err, @source) =>
        if err
          callback err
        else
          targetConstructor.one { _id: @targetId }, (err, @target) =>
            if err
              callback err
            else
              callback null, this
