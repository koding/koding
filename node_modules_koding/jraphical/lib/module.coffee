# coffeelint: disable=cyclomatic_complexity

{ Base, Model, ObjectId, Inflector, Register, race, daisy, dash } = require 'bongo'
{ extend, groupBy } = require 'underscore'
cloneDeep           = require 'lodash.clonedeep'
Relationship        = require './relationship'
Graphlet            = require './graphlet'

module.exports = class Module extends Model

  @limitEdges = (min, max, args) ->
    switch args.length
      when 1
        [callback] = args
        selector = {}
        options = { limit: min }
      when 2
        [selector, callback] = args
        options = { limit: min }
      when 3
        [selector, options, callback] = args
        limit = Math.min options.limit ? min, max
        if options.targetOptions
          options.options ?= {}
          options.options.limit = limit
        else
          options.limit = limit
      else
        throw new TypeError '''
          Module#limitEdges: expected 1, 2 or 3 parameters.
          '''
    return [selector, options, callback]

  @attachInterface = (verb, noun, isPlural, fn) ->
    [fn, lowFirstLetter] = [lowFirstLetter, fn] unless fn
    name = @getInterfaceName verb, noun, isPlural, yes
    this::[name] = fn
    return this

  @getDefaultRole = -> 'related'

  @setRelationships = do ->
    needsPopulated = (type) ->
      'string' is typeof type or \
      Array.isArray(type) and type.filter((item) -> 'string' is typeof item).length
    setRelationships = (constructor, relationships) ->
      if 'function' is typeof relationships
        relationships = relationships.call constructor
      constructor.relationships = relationships
      for own name, def of relationships
        if needsPopulated(def.targetType)
          do (def) ->
            process.nextTick -> constructor.emit 'needsPopulated', def, 'targetType'
        chain = def.inheritanceChain?()
        if chain and Module in chain
          def = { targetType: def }
        def.as or= def.targetType.getDefaultRole()
        constructor
        .attachInterface('add', name, no, getAdder_ constructor, name, def)
        .attachInterface('assure', name, no, getAssurer_ constructor, name, def)
        .attachInterface('remove', name, no, getRemover_ constructor, name, def)
        .attachInterface('fetch', name, yes, getFetcher_ constructor, name, def)
        .attachInterface('fetch', name, no, getFetcher_ constructor, name, def, yes)
        .attachInterface('count', name, yes, getCounter_ constructor, name, def)
    (relationships) ->
      constructor = this
      if 'function' is typeof relationships
        # when you pass "relationships" as a function, it will be defered until the next tick.
        # this can be useful for resolving circular dependencies (a requirement for graphs).
        process.nextTick setRelationships.bind null, constructor, relationships
      else
        setRelationships constructor, relationships
      constructor

  getOrientation = (def) ->
    orientation =
      if def.sourceType? then ['source', 'target']
      else if def.targetType? then ['target', 'source']
      else throw new Error 'Invalid relationship!'

  getCounter_ = (constructor, name, def) ->
    ->
      model = this

      switch arguments.length
        when 1
          [callback] = arguments
        when 2
          [selector, callback] = arguments
        when 3
          [selector, targetSelector, callback] = arguments

      selector ?= {}
      selector.as ?=
        if 'string' is typeof def.as then def.as
        else $in: def.as
      orientation   = getOrientation(def)
      outgoingName  = "#{orientation[0]}Name"
      outgoingType  = "#{orientation[0]}Type"
      incomingName  = "#{orientation[1]}Name"
      incomingId    = "#{orientation[1]}Id"

      [orientation] = orientation

      selector[outgoingName] or= \
        if Array.isArray(def[outgoingType])
          types = def[outgoingType].map((type) ->
            if type.encapsulatedSubclasses?
              type.encapsulatedSubclasses.map (subtype) -> subtype.name
            else
              type.name
          )
          types = types.reduce ((acc, item) -> (acc).concat item), []
          $in: types
        else if def[outgoingType].encapsulatedSubclasses?
          $in: def[outgoingType].encapsulatedSubclasses.map (type) -> type.name
        else
          def[outgoingType].name

      selector[incomingName] = constructor.name
      selector[incomingId]   = model.getId()

      unless targetSelector
        Relationship.count selector, callback
      else
        Relationship.someData selector, { targetId:1, targetName:1 }, (err, cursor) ->
          if err then callback err
          else
            cursor.toArray (err, docs) ->
              if err then callback err
              else unless docs?.length then callback null, 0
              else

                groups = groupBy docs, outgoingName
                totalCount = 0
                queue = Object.keys(groups).map (constructorName) -> ->
                  groupedDocs = groups[constructorName]
                  idSelector = { _id: { $in: (doc.targetId for doc in groupedDocs) } }
                  extend targetSelector, idSelector
                  konstructor = Base.constructors[constructorName]
                  konstructor.count targetSelector, (err, count) ->
                    if err then queue.fin err
                    else
                      totalCount += count
                      queue.fin()
                dash queue, -> callback null, totalCount


  getFetcher_ = (constructor, name, def, onlyOne = no) -> ->

    limit = 1  if onlyOne

    model = this
    args  = arguments

    switch args.length
      when 1
        [callback] = args
      when 2
        [selector, callback] = args
      when 3
        [selector, options, callback] = args
        if options.targetOptions
          { options, targetOptions } = options
          options or= {}

    if 'string' is typeof selector
      selector = { as: selector }

    selector    or= {}
    selector.as or=
      if 'string' is typeof def.as
      then def.as
      else $in: def.as

    orientation   = getOrientation(def)
    outgoingName  = "#{orientation[0]}Name"
    outgoingType  = "#{orientation[0]}Type"
    incomingName  = "#{orientation[1]}Name"
    incomingId    = "#{orientation[1]}Id"

    [orientation] = orientation

    selector[outgoingName] or= \
      if Array.isArray(def[outgoingType])
        types = def[outgoingType].map((type) ->
          if type.encapsulatedSubclasses?
            type.encapsulatedSubclasses.map (subtype) -> subtype.name
          else
            type.name
        )
        types = types.reduce ((acc, item) -> acc.concat item), []
        $in: types
      else if def[outgoingType].encapsulatedSubclasses?
        $in: def[outgoingType].encapsulatedSubclasses.map (type) -> type.name
      else
        def[outgoingType].name

    selector[incomingName] = constructor.name
    selector[incomingId]   = model.getId()

    fields          =
      'data.flags'  : 1
      timestamp     : 1

    idField         = "#{orientation}Id"
    fields[idField] = 1

    fields["#{orientation}Name"] = 1

    Relationship.someData selector, fields, options, (err, cursor) ->
      return callback err  if err

      cursor.toArray (err, docs) ->
        return callback err  if err

        unless docs?.length
          return callback null, unless limit then []

        ordered = {}
        docs.forEach (doc, index) ->
          ordered[doc[idField]] = index unless ordered[doc[idField]]?

        groups  = groupBy docs, outgoingName
        results = []

        targetOptions or= {}
        _targetOptions  = cloneDeep targetOptions

        if targetSelector = _targetOptions.selector or _targetOptions.query

          delete _targetOptions.selector
          delete _targetOptions.query

        else
          targetSelector = {}

        if _targetOptions.options?
          _targetOptions = _targetOptions.options

        collectOthers = race (i, type, group, next) ->

          ids         = (rel[idField] for rel in group)
          flags       = {}
          timestamps  = {}

          ids.forEach (id, index) ->
            flag = group[index].data?.flags
            flags[id] = flag if flag
            timestamps[id] = group[index].timestamp

          Base.constructors[type]
            .some extend(targetSelector,
              { _id: { $in: ids } }
            ), _targetOptions, (err, others) ->

              if others?
                others = for other in others
                  other.flags_ = flags[other.getId()]
                  other.timestamp_ = timestamps[other.getId()]
                  other
                results = results.concat others

              next()

        , ->

          if limit
            [results] = results
          else if not _targetOptions.sort?
            sortedResults = []
            results.forEach (result) ->
              sortedResults[ordered[result.getId()]] = result
            results = sortedResults.filter (value) -> value?

          callback null, results

        for own type, group of groups
          collectOthers type, group


  getAdder_ = (constructor, name, def) ->
    (target, options, callback) ->
      if 'function' is typeof options
        callback = options
        options = {}
      else unless callback
        callback = ->
      { targetType, as } = def
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          { as } = options
        if options.data?
          { data } = options

      if Array.isArray as
        throw new Error \
          '''
          You must specify the role when there are multiple options available!
          '''
      unless target.constructor is targetType or
             target.constructor.encapsulatedBy is targetType
        if Array.isArray(targetType)
          if target.constructor in targetType
            targetType = target.constructor
          else if target.constructor.encapsulatedBy in targetType
            targetType = target.constructor.encapsulatedBy
          else
            return callback new TypeError 'Type mismatch'
        else
          return callback new TypeError 'Type mismatch'
      rdef = {
        targetId    : target.getId()
        targetName  : targetType.name
        sourceId    : @getId()
        sourceName  : constructor.name
        as
      }

      if data
        rdef.data = data

      if target.constructor isnt targetType
        rdef.abstractTargetName = targetType.name
        rdef.targetName = target.constructor.name
      unless target.getId()
        callback new Error 'No target id!'
      else
        new Relationship(rdef).save (err, docs) ->
          if err
            callback err
          else if options?.respondWithCount
            delete rdef.targetId
            delete rdef.data
            Relationship.count rdef, (err, count) ->
              if err
                callback err
              else
                callback null, docs, count
          else
            callback err, docs

  getRemover_ = (constructor, name, def) ->
    (target, options, callback) ->
      [callback, options] = [options, callback] unless callback
      { targetType, as } = def
      as = as[0] if Array.isArray as
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          { as } = options
      rdef =
        targetId    : target.getId()
        targetName  : targetType.name
        sourceId    : @getId()
        sourceName  : constructor.name
      unless as is '*'
        rdef.as = as

      # TODO: I am implementing a hack here for the time being. Fix for real.
      Object.keys(rdef).forEach (key) ->
        delete rdef[key]  unless rdef[key]?
      # TODO: end dirty hack

      Relationship.remove rdef,
        unless options?.respondWithCount
          callback
        else ->
          delete rdef.targetId
          Relationship.count rdef, callback

  getAssurer_ = do ->
    addIt = (context, adder, target, options, callback) ->
      context[adder] target, options, (err) ->
        if err
          callback err
        else
          callback null, target
    (constructor, name, def) ->
      (target, options, callback) ->

        [callback, options] = [options, callback] unless callback
        [target, callback]  = [callback, target]  unless callback
        options ?= {}

        fetcher = @getInterfaceName 'fetch', name
        adder   = @getInterfaceName 'add', name

        selector =
          if target?
            targetId    : target.getId()
            as          : options?.as
          else {}
        @[fetcher] selector, (err, module) =>
          if err
            callback err
          else unless def.targetType
            callback new Error 'No target type!'
          else if module
            # update the timestamp on this relationship to reflect the
            # fact that it is being assured again, so the timestamp always
            # shows the most recent
            Relationship.update {
              targetId  : target.getId()
              sourceId  : @getId()
              as        : def.as
            }, { $set: { timestamp: new Date } }, (err) ->
              callback null, module
          else if target
            addIt this, adder, target, options, callback
          else
            target = new def.targetType
            target.save (err) =>
              if err
                callback err
              else
                addIt this, adder, target, options, callback

  remove_ = @::remove
  remove:(callback = ->) ->
    id = @getId()
    Relationship.remove { $or: [{ sourceId: id }, { targetId: id }] }, (err, rels) =>
      return callback err if err
      remove_.call this, callback

  beginGraphlet: -> new Graphlet { nodes: [this] }

  getFlag = (key, val) ->
    flag = {}
    flag["data.flags.#{key}"] = val
    flag

  getAs = (as) ->
    if Array.isArray as then $in: as else as

  updateFlag = (sourceId, targetId, as, flag, callback) ->
    Relationship.update { targetId, sourceId, as }, flag, callback

  unflag:(key, sourceId, as, callback = ->) ->
    flag = { $unset: getFlag key, 1 }
    updateFlag sourceId, @getId(), getAs(as), flag, callback

  flag:(key, val, sourceId, as, callback = ->) ->
    flag = { $set: getFlag key, val }
    updateFlag sourceId, @getId(), getAs(as), flag, callback

  save:(callback) ->
    Model::save.call this, callback

  parseTargetOptions = (options = {}) ->
    if selector = options.selector or options.query
      delete options.selector
      delete options.query
    else
      selector = {}
    { options, selector }

  collectOthers = (orientation, as, options, onlyOne, callback, err, cursor) ->
    idField   = "#{orientation}Id"
    nameField = "#{orientation}Name"
    if err then callback err
    else cursor.toArray (err, docs) ->
      if err then callback err
      else
        ordered = {}
        docs.forEach (doc, index) ->
          id = doc[idField]
          ordered[id] = index unless ordered[id]?
        groups = groupBy(docs, nameField)
        { options, selector } = parseTargetOptions(options)
        results = []
        queue = for own type, group of groups
          ->
            flags = {}
            ids = group.map (rel, index) ->
              id = rel[idField]
              flag = rel.data?.flags
              flags[id] = flag if flag
              id
            selector = extend selector, { _id: { $in: ids } }
            otherConstructor = Base.constructors[type]
            otherConstructor.some selector, options, (err, others) ->
              others = others.map (other) ->
                other.flags_ = flags[other.getId()]
                other
              results = results.concat others
              queue.fin()
        dash queue, ->
          if onlyOne
            [results] = results
          else
            sortedResults = []
            results.forEach (result) ->
              sortedResults[ordered[result.getId()]] = result
            results = sortedResults.filter (value) -> value?
          callback null, results

  filterRelatedIds:(ids, as, orientation, callback) ->
    [callback, orientation] = [orientation, callback]  unless callback
    selector = { as }
    id = @getId()
    search = if Array.isArray ids then $in: ids else ids
    if orientation is 'source'
      selector.targetId = search
      selector.sourceId = id
    else
      selector.sourceId = search
      selector.targetId = id
    Relationship.someData selector, { sourceId:1 }, (err, cursor) ->
      if err then callback err
      else
        cursor.toArray (err, docs) ->
          if err
            callback err
          else
            callback null, (doc.sourceId for doc in docs)

  fetch:(orientation, name, as, options, callback) ->
    [callback, options] = [options, callback] unless callback
    currentPosition = switch orientation
      when 'target' then 'source'
      when 'source' then 'target'
    options   ?= {}
    callback  ?= ->
    if options.targetOptions?
      { options, targetOptions } = options
    onlyOne = options.onlyOne ? no
    options.limit = 1 if onlyOne
    edgeSelector = if Array.isArray(as) then { as: { $in:as } } else { as }
    edgeSelector["#{orientation}Name"]      = name
    edgeSelector["#{currentPosition}Name"]  = @constructor.name
    edgeSelector["#{currentPosition}Id"]    = @getId()
    fields = {}
    fields["#{orientation}Id"]  = 1
    fields["#{orientation}Name"]  = 1
    fields['data.flags']        = 1
    Relationship.someData edgeSelector, fields, options, collectOthers.bind(
      this, orientation, as, targetOptions, onlyOne, callback
    )

  hasTarget: (target, as, callback) ->
    Relationship.count {
      targetName  : target.constructor.name
      targetId    : target.getId()
      sourceId    : @getId()
      sourceName  : @constructor.name
      as
    }, (err, count) ->
      return callback err  if err
      callback null, count >= 0
