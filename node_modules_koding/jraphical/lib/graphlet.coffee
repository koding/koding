fetchRootTraverse = require 'traverse'
{ Base, Model, Inflector, future, sequence, race, dash } = require 'bongo'
{ extend } = require 'underscore'
{ slice } = []

Relationship = require './relationship'
LazyNode = require './lazynode'

module.exports = future class Graphlet

  constructor:(options = {}) ->
    @[option]? value for option, value of options

  lasso: ->
    @abstractly 'lasso', arguments

  abstractly: future (pipeline, method, arg, next) ->
    last = pipeline.last()
    nodes = last.nodes or last.edges
    unless nodes?
      throw new Error 'abstractly needs nodes or edges'
    if nodes
      callAbstractly = race (node, next) ->
        abstractly = node.abstractly
        if 'function' is typeof abstractly
          abstractly.call node, method, arg, next
        else
          next()
      , next
      callAbstractly node for node in nodes
    this

  reverse: do ->
    reverse = (arr) ->
      for own _, collection of arr
        collection.reverse?()
    future (pipeline, isDeep, next) ->
      [next, isDeep] = [isDeep, next] unless next
      if isDeep is true
        for stage in pipeline
          reverse stage
      else
        reverse pipeline.last()
      next()
  #
  #
  # fetch: future (pipeline, name, rest..., next) ->
  #   @invoke 'fetch', name, rest..., next
  #
  # assure: future (pipeline, rest..., next) ->
  #   @[@getInterfaceName(name)] 'assure', rest..., next
  #
  # add: future (pipeline, rest..., next) ->
  #   @[@getInterfaceName(name)] 'add', rest..., next
  #
  # remove: future (pipeline, rest..., next) ->
  #   @[@getInterfaceName(name)] 'fetch', rest..., next
  #
  #

  edgesOfEach:do ->

    selectorCallback = (callback, err, relationships) ->
      return callback err  if err
      @push relationships...
      callback null

    selectFromNode = (node, sharedOptions, acc, callback) ->
      { selector, query, limit, sort, skip, hint } = sharedOptions
      selector = extend {}, selector ? query, { sourceId: node.getId() }
      options = { limit, sort, skip, hint }
      Relationship.some selector, options, selectorCallback.bind acc, callback

    selectFromEdge = (edge, sharedOptions, acc, callback) ->
      { selector, query, limit, sort, skip, hint } = sharedOptions
      selector = extend {}, selector ? query, { sourceId: edge.targetId }
      options = { limit, sort, skip, hint }
      Relationship.some selector, options, selectorCallback.bind acc, callback

    future (pipeline, options, next) ->
      last = pipeline.last()

      { andNext } = pipeline
      delete pipeline.andNext

      [next, options] = [options, next] unless next
      options or= {}

      acc = if andNext then last.nodes ? last.edges else []
      queue =
        if last.nodes
          last.nodes.map (node) -> ->
            selectFromNode node, options, acc, (err) ->
              if err then next err
              else queue.fin()
        else if last.edges
          last.edges.map (edge) -> ->
            selectFromEdge edge, options, acc, (err) ->
              if err then next err
              else queue.fin()

      dash queue, ->
        pipeline.push { edges: acc }
        next()

  edges: future (pipeline, options, next) ->
    last = pipeline.last()

    { andNext } = pipeline
    delete pipeline.andNext

    [next, options] = [options, next] unless next
    options or= {}

    { selector, query, limit, sort, skip, hint } = options
    selector or= query or= {}

    if last.nodes
      extend selector, { sourceId: { $in: (node.getId() for node in last.nodes) } }

    else if last.edges
      extend selector, { sourceId: { $in: (edge.targetId for edge in last.edges) } }

    Relationship.some selector, options, (err, relationships) ->
      if err
        next err
      else
        if andNext
          last.edges.push relationships...
          delete last.nodes
        else
          pipeline.push { edges: relationships }
        next()

    this

  nodes: future (pipeline, options, next) ->
    last = pipeline.last()

    [next, options] = [options, next] unless next
    options or= {}

    if last?.nodes
      throw new Error \
        "Can't traverse to nodes from nodes.  You need to select some edges."

    if Array.isArray options
      pipeline.push { nodes: options }
      next()

    else
      nodes = { nodes: [] }
      pipeline.push nodes

      collectNodes = race (i, constructor, pipeline, selector, options, fin) ->
        root = pipeline.root()
        constructor.some selector, options, (err, instances) ->
          if err
            next err
          else
            nodes.nodes.push instances...
            fin()
      , next

      { selector, query, limit, sort, skip, hint } = options

      selector or= query or= {}

      if last.edges
        targets = {}
        for edge in last.edges
          targets[edge.targetName] or= []
          targets[edge.targetName].push edge.targetId
        unless Object.keys(targets).length then next()
        else for own targetName, targetIds of targets
          constructor = Base.constructors[targetName]
          collectNodes constructor, pipeline, (extend {}, selector, { _id:
            if targetIds.length > 1
              { $in: targetIds }
            else
              targetIds[0]
            }
          ), { limit, sort, skip, hint }
      else
        throw new Error 'this is a strange condition'
    this

  and: future (pipeline, next) ->
    last = pipeline.last()
    type = \
      if last.nodes then 'edges'
      else if last.edges then 'nodes'
    last[type] = pipeline[pipeline.length - 2][type]
    pipeline.andNext = yes
    next()

  tap: future (pipeline, callback, next) ->
    callback pipeline
    next()

  endGraphlet: future (pipeline, next) ->
    nodes = {}
    graphlet = []
    for stage, i in pipeline when stage.nodes?
      for node in stage.nodes
        constructorName = node.constructor.name
        node = nodes[node.getId()] = node.get()
        node.bongo_ = { constructorName }
        graphlet.push node if i is 0
    for stage in pipeline when stage.edges?
      for edge in stage.edges
        sourceNode = nodes[edge.sourceId] or= new LazyNode edge.sourceName, edge.sourceId
        targetNode = nodes[edge.targetId] or= new LazyNode edge.targetName, edge.targetId
        targetCollection = sourceNode[Inflector.pluralize edge.as] or= []
        targetCollection.push targetNode
    pipeline.push { graphlet }
    next()

  fetchGraphlet:(callback) ->
    @then (err, pipeline) ->
      if err
        callback err
      else
        { graphlet } = pipeline.last()
        callback null, graphlet

  fetchRoot:(index, callback) ->
    [callback, index] = [index, callback] unless callback
    index or= 0
    @fetchGraphlet (err, graphlet) ->
      if err
        callback err
      else
        callback null, graphlet[index]

  traverse:(callback) ->
    @then (err, obj) ->
      if err
        callback err
      else
        callback null, new Traverse obj
