module.exports = class Broker
  amqp = require 'amqp'
  {dash} = require 'sinkrow'
  {extend} = require 'underscore'
  DELIMITER = 'Î»'

  constructor: (options) ->
    @options = options
    options = extend {}, options
    @eventMap = {}
    @connection = amqp.createConnection options, reconnect: no
    @connection.on 'ready', => @readyState = 1
    @connection.on 'error', (err) => @emit 'error', err
    @connection.setMaxListeners(0)
    @readyState = 0
    # @connection.on 'ready', callback if callback

  createExchange: (exchangeName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {}
    @ready =>

      options ?= {}
      options.durable ?= true
      options.autoDelete ?= true

      @connection.exchange exchangeName, options, callback
      @connection.on 'error', @emit.bind this, 'error'

  createQueue: (queueName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {durable:yes, exclusive:yes}

    @ready =>
      @connection.queue queueName, options, callback

  getExchange: (name) ->
    @connection.exchanges[name]

  funnel:(exchangeName, queueName)->
    @ready =>
      @createExchange exchangeName, (exchange)=>
        @createQueue queueName, {autoDelete:no}, (queue)=>
          queue.bind exchange, '#'
          exchange.close()
          @createQueue '', (dcQueue)->
            dcQueue.bind exchange, 'disconnected'
            dcQueue.subscribe ->
              queue.unbind exchange, '#'
              queue.close()
              dcQueue.destroy()#.addCallback -> dcQueue.close()
  ###
  Bind exchange named 'destination' to exchange named 'source' on a
  routing key so that message come to 'source' exchange will flow to
  'destination' exchange if that message has the routing key.
  An auto-delete 'source' exchange will be removed if binding removed,
  but auto-delete 'destination' exchange will not.
  ###
  bindExchange: (destination, source, routingKey) ->
    @ready =>
      destination.options ?= durable: true, autoDelete: false
      source.options ?= durable: true, autoDelete: false

      queue = [
        createDestination = =>
          @createExchange destination.name, destination.options, (exchange) ->
            destination.exchange = exchange
            queue.fin()
        createSource = =>
          @createExchange source.name, source.options, (exchange) ->
            source.exchange = exchange
            queue.fin()
      ]

      dash queue, ->
        destination.exchange.bind source.exchange, routingKey

  unbindExchange: (destination, source, routingKey) ->
    @ready =>
      destinationExchange = (@connection.exchanges or {})[destination]
      sourceExchange = (@connection.exchanges or {})[source]
      return unless destinationExchange? and sourceExchange?

      destinationExchange.unbind sourceExchange, routingKey

  # Binds a queue to an exchange on the specified routing.
  # Supports optional options for both exchange and queue.
  # Automatically closes the channel used to declare the
  # exchange after the binding is done.
  bindQueue: (name, exchange, routing, options, callback) ->
    @ready =>
      if 'function' is typeof options
        callback = options
        options = {}
      options ?= {}
      { exchangeDurable
        exchangeAutoDelete
        queueDurable
        queueExclusive
        queueAutoDelete } = options
      queueOptions =
        durable: unless queueDurable? then true else queueDurable
        exclusive: unless queueExclusive? then true else queueExclusive

      queueOptions.autoDelete = queueAutoDelete if queueAutoDelete?

      #unless exchange of (@connection.exchanges or {})
      exchangeOptions =
        durable: unless exchangeDurable? then true else exchangeDurable
        autoDelete: unless exchangeAutoDelete? then true else exchangeAutoDelete

      @createExchange exchange, exchangeOptions, (exchangeObj) =>
        @createQueue name, queueOptions, (queue) ->
          queue.bind exchange, routing
          queue.on 'queueBindOk', =>
            exchangeObj.close()
            callback? queue, exchange
      # else
      #   @createQueue name, queueOptions, (queue) =>
      #     queue.bind exchange, routing
      #     queue.on 'queueBindOk', =>
      #       @connection.exchanges?[exchange]?.close()
      #       callback? queue, exchange

  # A wrapper to consume messages from a queue.
  #
  # (String) queueName - name of the queue
  # (Object) options - the options for both the queue and the message.
  # (Function) callback - the function to call when message arrives.
  #
  # Available options for queue are:
  #  passive: boolean, default false. If set, the server will not create
  #           the queue. The client can use this to check whether a queue
  #           exists without modifying the server state.
  #  durable: boolean, default false. Durable queues remain active when a
  #           server restarts. Note that durable queues don't necessarily
  #           hold persistent messages, although it does not make sense to
  #           send persistent messages to a transient queue.
  #  exclusive: boolean, default false. Also implies 'autoDelete'.
  #  autoDelete: boolean, default true. The queue is deleted when all
  #             consumers have finished using it. If there was no consumer
  #             ever on the queue, it won't be deleted.
  #  noDeclare: boolean, default false. If set, the queue will not be declared,
  #             this will allow a queue to be deleted if you dont know its
  #             previous options.
  #  arguments: a map of additional arguments to pass in when creating a queue.
  #  closeChannelOnUnsubscribe : a boolean when true the channel will close on
  #             unsubscrube, default false.
  #
  # For message options, here are the available:
  #  ack: boolean, default false. This flag tells the server whether deliver
  #       a single message at a time, or as fast as messages come in. If set,
  #       need to use queue.shift() to let the server knows the acknowledge.
  #  prefetchCount: integer, default 1. How many messages the server will send
  #                 before this consumer needs to ack. 0 makes it unlimited.
  #  routingKeyInPayload: boolean, false. Whether to inject the routing key
  #                       into the JSON payload received.
  #  deliveryKeyInPayload: boolean, false. Whether to inject the delivery key
  #                         into the JSON payload received.
  # subscribe: (queueName, options, callback) ->
  #   @ready =>
  #     if 'function' is typeof queueName
  #       callback = queueName
  #       queueName = ''

  #     else if 'function' is typeof options
  #       callback = options
  #       options = {durable: true, exclusive: true}

  #     options ?= {}
  #     options.durable ?= true
  #     options.exclusive ?=true

  #     deliverOpts = {}
  #     deliverOpts.ack = options.ack if options.ack?
  #     deliverOpts.prefetchCount = options.prefetchCount if options.prefetchCount?

  #     @createQueue queueName, options, (queue) =>
  #       result = queue.subscribe deliverOpts, (payload, headers, deliveryInfo) =>
  #         message = @cleanPayload payload
  #         callback message, headers, deliveryInfo

  ready:(callback)->
    if @readyState is 1
      callback()
    else
      @connection.once 'ready', -> callback()

  # A wrapper to publish a message to an exchange on a routing key.
  #
  # (String) channel - name of the exchange
  # (String) event - the routing key
  # (Object|String) payload
  # (Object) options - the options for both the exchange and the message.
  # To specify the type of exchange, set `durable` and `autoDelete`.
  #
  # For message options, here are the available:
  #  mandatory: boolean, default false. This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is false, the server silently drops the message.
  #  immediate: boolean, default false. This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is false, the server will queue the message, but with no guarantee that it will ever be consumed.
  #  contentType: default 'application/octet-stream'
  #  contentEncoding: default null.
  #  headers: default {}. Arbitrary application-specific message headers.
  #  deliveryMode: Non-persistent (1) or persistent (2)
  #  priority: The message priority, 0 to 9.
  #  replyTo: Usually used to name a reply queue for a request message.
  #
  # exchange.publish can also take a callback, but for the simplicity of
  # emit signature, it is not used.
  emit: (channel, event, payload, options = {}) ->
    {durable, autoDelete} = options
    exchangeOptions =
      durable     : unless durable? then no else durable
      autoDelete  : if autoDelete? then autoDelete else yes
      type        : 'fanout'

    delete options.durable
    delete options.autoDelete

    payload += ''  if payload?

    # There is a case when payload is undefined, causing exception "Type Error:
    # Argument must be a string" when checking Buffer's length.
    # node-amqp does not handle empty string as payload either, so use an empty
    # object for now - S.T
    payload ?= null

    @createExchange channel, exchangeOptions, (exchange) ->
      exchange.publish event, payload, options
      # we need to close the amqp channel, not leak one per emit!!  C.T.
      exchange.close()

  # A convenient wrapper for binding a queue to an exchange and starting to
  # consume from that queue.
  # The channel used to declare the exchange for binding is closed in bindQueue
  # method, so no need to clean it up here.
  on: (channel, event, queueName, callback) ->
    # eventMap = @eventMap
    # key = channel+DELIMITER+event
    # return if eventMap[key]
    [callback, queueName] = [queueName, callback] unless callback?
    queueName ?= ''

    @ready =>
      # bindQueue method ensures existence of exchange and queue
      @bindQueue queueName, channel, event, (queue, exchangeName) =>
        # @subscribe queueName, callback
        queue.subscribe (payload, headers, deliveryInfo) =>
          message = @cleanPayload payload
          callback message, headers, deliveryInfo

    # createQueue @connection, '', (queue) ->
    #     queue.bind channel, event
    #     queue.on 'queueBindOk', ->
    #         queue.subscribe (payload) ->
    #             console.log payload
    #             callback payload.data
    #         .addCallback (ok) ->
    #             ctag = ok.consumerTag
    #             eventMap[key] = [queue, ctag]

  off: (channel, event, callback) ->
    key = channel+DELIMITER+event
    [queue, ctag] = @eventMap[key]
    queue.unsubscribe(ctag)
    queue.destroy()

  cleanPayload: (payload) ->
    unless payload.data? and payload.contentType?
      return payload
    else
      message = payload.data+""
      if 'string' is typeof message
        return message
      else
        try
          message = JSON.parse message
          return message
        catch e
          return message: 'Parse error!'

  # Alias
  trigger: @::emit
  bind: @::on
  unbind: @::off
