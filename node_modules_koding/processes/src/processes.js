// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, Processes, Worker, argv, e, exec, flipped, fork, fs, hat, kontrold, log4js, mq, os, spawn, traverse, wait, _, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  argv = require('optimist').argv;

  traverse = require('traverse');

  _ = require('underscore');

  fs = require("fs");

  os = require("os");

  hat = require('hat');

  _ref = require("child_process"), exec = _ref.exec, spawn = _ref.spawn, fork = _ref.fork;

  EventEmitter = require("events").EventEmitter;

  Worker = require('koding-worker');

  mq = require('koding-config-manager').load("main." + argv.c).mq;

  kontrold = require('koding-config-manager').load("main." + argv.c).kontrold;

  log4js = require('log4js');

  log4js.configure({
    appenders: [
      {
        type: 'console'
      }
    ],
    replaceConsole: true
  });

  try {
    fs.mkdirSync(__dirname + "/.tmp/");
  } catch (_error) {
    e = _error;
  }

  flipped = function(fn) {
    return function() {
      return fn.apply(this, __slice.call(arguments).reverse());
    };
  };

  wait = flipped(setTimeout);


  /* HANDLE SIGNALS and KILLS */

  process.on('SIGTERM', (function(_this) {
    return function() {
      console.log("going down");
      return process.exit(0);
    };
  })(this));

  module.exports = Processes = (function(_super) {
    __extends(Processes, _super);

    function Processes(options) {
      var main, previouschildProcessesContainerDir;
      if (options == null) {
        options = {};
      }
      main = options.main;
      this.list = {};
      this.child = null;
      this.workerProcess = {};
      this.disableRestart = false;
      this.childProcessesContainerDir = "" + __dirname + "/.tmp";
      if (main) {
        previouschildProcessesContainerDir = "" + this.childProcessesContainerDir + "." + (Date.now());
        fs.renameSync(this.childProcessesContainerDir, previouschildProcessesContainerDir);
        fs.mkdirSync(this.childProcessesContainerDir);
        exec("rm -rf " + previouschildProcessesContainerDir, function(err, stdout, stderr) {
          if (err) {
            return console.log("couldn't delete previous process tree at " + previouschildProcessesContainerDir);
          }
        });
      }
    }

    Processes.prototype.fork = function(options, callback) {
      options.fork = true;
      return this._run(options, callback, (function(_this) {
        return function(cb) {
          return callback(cb);
        };
      })(this));
    };

    Processes.prototype.spawn = function(options, callback) {
      options.spawn = true;
      return this._run(options, callback);
    };

    Processes.prototype.exec = function(cmd, callback) {
      return this.spawn({
        name: Date.now(),
        cmd: cmd,
        restart: false,
        stdout: process.stdout,
        stderr: process.stderr,
        onExit: callback
      });
    };

    Processes.prototype.run = function(name, cmd, options, callback) {
      if (callback == null) {
        callback = function() {};
      }
      if (!cmd) {
        cmd = name;
      }
      return this.spawn({
        name: name,
        cmd: cmd,
        restart: false,
        verbose: false
      }, callback);
    };

    Processes.prototype._run = function(options, callback) {
      var name, restartTimeout, verbose, _ref1;
      name = options.name, restartTimeout = options.restartTimeout, verbose = options.verbose;
      if (options.name == null) {
        options.name = Date.now();
      }
      if (options.stdout == null) {
        options.stdout = process.stdout;
      }
      if (options.stderr == null) {
        options.stderr = process.stderr;
      }
      if (options.verbose == null) {
        options.verbose = true;
      }
      if (options.restart == null) {
        options.restart = true;
      }
      if (options.restartTimeout == null) {
        options.restartTimeout = 100;
      }
      if ((_ref1 = options.kontrol) != null ? _ref1.enabled : void 0) {
        console.log("[PROCESSES][" + name + "] kontrold enabled with mode: '" + options.kontrol.startMode + "'");
        return this.kontroldProcess(options);
      } else {
        this.child = this.startProcess(options);
        return this.populateChildObject(options, this.child);
      }
    };

    Processes.prototype.getDate = function() {
      var d, pad;
      d = new Date();
      pad = function(n) {
        if (n < 10) {
          return "0" + n;
        } else {
          return n;
        }
      };
      return "" + (d.getUTCFullYear()) + "-" + (pad(d.getUTCMonth() + 1)) + "-" + (pad(d.getUTCDate())) + "T" + (pad(d.getUTCHours())) + ":" + (pad(d.getUTCMinutes())) + ":" + (pad(d.getUTCSeconds())) + "Z";
    };

    Processes.prototype.startProcess = function(options) {
      var args, cmd, cmdA, name, opts, process, stderr, stdout, verbose;
      name = options.name, opts = options.opts, cmd = options.cmd, stdout = options.stdout, stderr = options.stderr, verbose = options.verbose;
      if ("string" === typeof options.cmd) {
        cmdA = cmd.split(" ");
      } else {
        if (verbose) {
          console.log(e = "[PROCESSES][ERROR][" + name + "] Can't start without a valid cmd param.");
        }
      }
      if (options.fork) {
        process = cmdA[0], args = 2 <= cmdA.length ? __slice.call(cmdA, 1) : [];
        this.child = fork(process, args, opts);
      } else {
        this.child = exec(cmd);
        if (stdout) {
          this.child.stdout.pipe(stdout);
        }
        if (stderr) {
          this.child.stderr.pipe(stderr);
        }
      }
      return this.child;
    };

    Processes.prototype.kontroldProcess = function(options) {
      var binaryEnabled, name, onExit, restart, restartTimeout, uuid, verbose, workerProc;
      name = options.name, onExit = options.onExit, restart = options.restart, restartTimeout = options.restartTimeout, verbose = options.verbose;
      if (verbose && options.kontrol.forceStart) {
        console.log("[PROCESSES][" + name + "] force mode enabled. Trying to stop and kill all other " + name + " workers");
      }
      if (options.kontrol.binary != null) {
        uuid = options.kontrol.binary;
        binaryEnabled = true;
      } else {
        uuid = hat();
        binaryEnabled = false;
      }
      mq.vhost = kontrold.vhost;
      workerProc = new Worker({
        mq: mq,
        command: options.kontrol.registerToProxy ? "addWithProxy" : "add",
        hostname: options.kontrol.hostname,
        name: name,
        uuid: uuid,
        option: options.kontrol.startMode,
        interval: options.reportInterval,
        port: options.kontrol.port,
        proxyName: options.kontrol.proxyName,
        binary: binaryEnabled
      });
      this.workerProcess[name] = workerProc;
      workerProc.connect();
      if (verbose) {
        console.log("[PROCESSES][" + name + "] connected to kontrold. waiting for instructions...");
      }

      /* Start */
      workerProc.on('permissionToRun', (function(_this) {
        return function() {
          var _ref1;
          if (((_ref1 = _this.list[name]) != null ? _ref1.name : void 0) !== name) {
            if (verbose) {
              console.log("[PROCESSES][" + name + "] received 'add' message from Kontrold. starting child_process.");
            }
            _this.child = _this.startProcess(options);
            _this.populateChildObject(options, _this.child);

            /* Child */
            workerProc.startReporter("ack");
            workerProc.stopReporter("add");
            return workerProc.fetchWorkerExchange(function(workerExchange) {
              var worker;
              worker = workerProc.worker;
              worker.message.command = "update";
              worker.status = 0;
              worker.pid = _this.list[name].pid;
              worker.timestamp = _this.getDate();
              return workerExchange.publish("input.worker", {
                worker: worker
              }, {
                appId: "" + _this.workerProcess[name].worker.uuid
              });
            });
          }
        };
      })(this));

      /* Kill */
      workerProc.on('killWorkerProcess', (function(_this) {
        return function() {
          console.log("killing worker:", name);
          workerProc.worker.status = 1;
          if (verbose) {
            console.log("[PROCESSES][" + name + "] received 'kill' message from Kontrold. Sending SIGTERM to the child_process.");
          }
          return _this.kill(name);
        };
      })(this));
      return workerProc.on('killForceWorkerProcess', (function(_this) {
        return function() {
          _this.disableRestart = true;
          console.log("killing worker:", name);
          workerProc.worker.status = 1;
          if (verbose) {
            console.log("[PROCESSES][" + name + "] received 'killForce' message from Kontrold. Sending SIGTERM to the child_process.");
          }
          return _this.kill(name);
        };
      })(this));
    };

    Processes.prototype.populateChildObject = function(options, child) {
      var args, childObj, cmd, d, die, log, modulePath, name, onExit, onMessage, restart, restartTimeout, stderr, stdout, verbose, workerProc;
      name = options.name, onMessage = options.onMessage, modulePath = options.modulePath, args = options.args, restart = options.restart, restartTimeout = options.restartTimeout, cmd = options.cmd, log = options.log, onExit = options.onExit, stdout = options.stdout, stderr = options.stderr, verbose = options.verbose, die = options.die;
      if (onExit == null) {
        onExit = function() {};
      }
      if (verbose) {
        console.log("[PROCESSES][" + name + "] started the process: " + name + " with pid: " + this.child.pid);
      }
      this.createPidFile(child.pid, name);
      childObj = {
        name: name,
        process: child,
        pid: child.pid,
        verbose: verbose
      };
      workerProc = this.workerProcess[name];
      if (cmd) {
        childObj.cmd = cmd;
      } else if (modulePath) {
        childObj.fork = {
          modulePath: modulePath,
          args: args,
          options: options
        };
      }
      if (this.list[name]) {
        d = Date.now();
        if (verbose) {
          console.log("[WARN][Processes] process name '" + name + "' not unique. to be able to kill it properly it is now: " + name + "-" + d);
        }
        name += "-" + d;
      }
      this.list[name] = childObj;
      if (die != null ? die.after : void 0) {
        if (verbose) {
          console.log("[PROCESSES][" + name + "]i will kill this process:" + name + " every " + die.after + "msecs");
        }
        wait(die.after, (function(_this) {
          return function() {
            if (verbose) {
              console.log("[PROCESSES][" + name + "]it's time you die process:" + name);
            }
            return _this.kill(name);
          };
        })(this));
      }
      child.on('exit', (function(_this) {
        return function() {
          console.log("[PROCESSES][" + name + "] observing a process exiting", child.pid);
          if (verbose) {
            console.log("[PROCESSES][" + name + "] did exit.");
          }
          _this.emit("exit", child.pid, name);
          delete _this.list[name];
          if (workerProc != null) {
            workerProc.stopReporter("ack");
            workerProc.stopReporter("add");
            workerProc.connection.end();
            workerProc.connection.destroy();
            if (_this.workerProcess[name] === workerProc) {
              return delete _this.workerProcess[name];
            }
          }
        };
      })(this));
      child.on('close', (function(_this) {
        return function() {
          if (verbose) {
            console.log("[PROCESSES][" + name + "] did close.");
          }
          _this.emit("close", child.pid, name);
          onExit(child.pid, name);
          if (_this.disableRestart === true) {
            if (verbose) {
              console.log("[PROCESSES][" + name + "] restart is disabled because of force mode.");
            }
            _this.disableRestart = false;
            return;
          }
          if (restart === true) {
            if (!restartTimeout) {
              restartTimeout = 1;
            }
            wait(restartTimeout, function() {
              return _this._run(options);
            });
            if (verbose) {
              return console.log("[PROCESSES][" + name + "] restarting the process in " + restartTimeout + " msecs.");
            }
          }
        };
      })(this));
      child.on('message', (function(_this) {
        return function(msg) {
          if ("function" === typeof onMessage) {
            onMessage(msg);
          }
          if (msg['process-monitor']) {
            delete msg['process-monitor'];
            if (workerProc != null) {
              msg['uuid'] = workerProc.worker.uuid;
              return workerProc.fetchWorkerExchange(function(workerExchange) {
                workerProc.worker.message.command = "ack";
                return workerExchange.publish("input.worker", {
                  monitor: msg
                }, {
                  appId: "" + _this.workerProcess[name].worker.uuid
                });
              });
            }
          }
        };
      })(this));
      return childObj;
    };

    Processes.prototype.createPidFile = function(pid, name) {
      return fs.writeFileSync("" + this.childProcessesContainerDir + "/" + process.pid + "." + pid, "");
    };

    Processes.prototype.get = function(name) {
      if (this.list[name]) {
        return this.list[name].process;
      } else {
        return console.log("[ERROR][Processes] " + name + " Can't be found.");
      }
    };

    Processes.prototype.fetchChildren = function(parentPid, callback) {
      var findChildren;
      findChildren = function(arr, pid) {
        var findChildrenRec;
        findChildrenRec = function(pid, root) {
          var c, i;
          if (root == null) {
            root = true;
          }
          c = {};
          pid = "" + pid;
          i = -1;
          arr.forEach(function(item) {
            var child, parent, _ref1;
            _ref1 = item.split("."), parent = _ref1[0], child = _ref1[1];
            if (parent === pid) {
              return c[child] = findChildrenRec(child, false);
            }
          });
          return c;
        };
        arr = traverse(findChildrenRec(pid)).paths();
        arr.forEach(function(group) {
          return group.reverse();
        });
        arr = _.sortBy(arr, function(a) {
          return a.length * -1;
        });
        return _.uniq(_.flatten(arr, true));
      };
      return fs.readdir(this.childProcessesContainerDir, function(err, list) {
        if (err) {
          return callback(err);
        } else {
          return callback(null, findChildren(list, parentPid));
        }
      });
    };

    Processes.prototype.killAllChildren = function(parentPid, callback) {
      return this.fetchChildren(parentPid, function(err, orderedKillList) {
        var pidPair;
        console.log("ordered kill list: " + orderedKillList);
        if (!err) {
          pidPair = [];
          orderedKillList.forEach(function(pid) {
            var deleteFile;
            console.log("killing children: " + pid);
            try {
              pidPair.push(pid);
              process.kill(+pid);
              if (pidPair.length === 2) {
                pidPair.reverse();
                deleteFile = pidPair.join(".");
                console.log("deleting " + deleteFile);
                fs.unlinkSync(deleteFile);
                return pidPair.shift();
              }
            } catch (_error) {
              e = _error;
              return console.log("child process " + pid + " did not exist. not killed by me.");
            }
          });
          return callback(null);
        }
      });
    };

    Processes.prototype.sendMessage = function(name, msg) {
      var _ref1, _ref2;
      if ((_ref1 = this.list[name]) != null ? (_ref2 = _ref1.process) != null ? _ref2.send : void 0 : void 0) {
        return this.list[name].process.send(msg);
      }
    };

    Processes.prototype.kill = function(name, callback) {
      var pid;
      if (callback == null) {
        callback = (function() {});
      }
      if (!this.list[name]) {
        return console.log("[PROCESSES][" + name + "] cant kill " + name + ", couldn't find it.");
      } else {
        pid = this.list[name].pid;
        console.log("[PROCESSES][" + name + "] killing parent: " + pid);
        return this.killAllChildren(pid, function(err, res) {
          console.log("[PROCESSES][" + name + "] killing " + name + " " + pid);
          return process.kill(pid);
        });
      }
    };

    return Processes;

  })(EventEmitter);

}).call(this);
