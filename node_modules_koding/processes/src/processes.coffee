# this is a work in progress.
# it's doing proper cleanup and management of child processes
# use it with care, not all edge cases are covered.
#
# author @devrim

{argv}              = require 'optimist'
traverse            = require 'traverse'
_                   = require 'underscore'
fs                  = require "fs"
os                  = require "os"
hat                 = require 'hat'
{exec,spawn,fork}   = require "child_process"
{EventEmitter}      = require "events"
Worker              = require 'koding-worker'
{kontrold}          = require('koding-config-manager').load("main.#{argv.c}")

try
  fs.mkdirSync __dirname+"/.tmp/"
catch e
  # do nothing, probably dir is already there.

################################
### HANDLE SIGNALS and KILLS ###
################################

# guaranteed death.
process.on 'SIGTERM', =>
  console.log "going down"
  process.exit(0)

class Processes extends EventEmitter
  constructor:(options={})->
    {main}         = options
    @list          = {}
    @child         = null
    @workerProcess = {}
    @disableRestart = no
    @childProcessesContainerDir = __dirname+"/.tmp"
    if main
      previouschildProcessesContainerDir = @childProcessesContainerDir+"."+Date.now()
      fs.renameSync @childProcessesContainerDir, previouschildProcessesContainerDir
      fs.mkdirSync @childProcessesContainerDir
      exec "rm -rf #{previouschildProcessesContainerDir}",(err,stdout,stderr)->
        if err
          console.log "couldn't delete previous process tree at #{previouschildProcessesContainerDir}"
        #else
        #  console.log "previous process tree is deleted."
        
  fork: (options,callback) ->
    options.fork = yes
    @run options,callback, (cb) =>
      callback cb

  spawn: (options,callback)->
    options.spawn = yes
    @run options,callback

  exec: (cmd,callback)->
    @spawn
      name  : Date.now()
      cmd   : cmd
      restart : no
      stdout : process.stdout
      stderr : process.stderr
      onExit  : callback

  # our main function is this. Either it is started normal, or it is wrapped
  # via kontrold amqp process
  run: (options,callback) ->
    {name, restartTimeout, verbose} = options

    options.name            ?= Date.now()
    options.restartTimeout  ?= 1000
    options.verbose         ?= no

    if options.kontrol?.enabled
      console.log "[PROCESSES][#{name}] kontrold enabled with mode: '#{options.kontrol.startMode}'"
      @kontroldProcess options
    else
      @child = @startProcess options
      @populateChildObject options, @child

  getDate: ->
    d = new Date()
    pad = (n) ->
      (if n < 10 then "0" + n else n)
    d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z"

  startProcess: (options) ->
    {name,opts,cmd,stdout,stderr} = options

    if "string" is typeof options.cmd
      cmdA = cmd.split(" ")
    else
      console.log e = "[PROCESSES][ERROR][#{name}] Can't start without a valid cmd param." if verbose
      return callback e

    if options.fork
      @child = fork cmdA[0],cmdA[1...],opts
    else
      # @child = spawn cmdA[0],cmdA[1...]
      @child = exec cmd # cmdA is split wrongly when quotation marks are involved
      @child.stdout.pipe stdout if stdout
      @child.stderr.pipe stderr if stderr

    return @child

  kontroldProcess: (options) ->
    {name,onExit,restart,restartTimeout,verbose} = options

    console.log "[PROCESSES][#{name}] force mode enabled. Trying to stop and kill all other #{name} workers" if verbose and options.kontrol.forceStart

    if options.kontrol.binary?
      uuid          = options.kontrol.binary
      binaryEnabled = yes
    else
      uuid          = hat()
      binaryEnabled = no

    @workerProcess[name] = new Worker {
      kontrold
      command            : if options.kontrol.registerToProxy then "addWithProxy" else "add"
      hostname           : options.kontrol.hostname
      name               : name
      uuid               : uuid
      option             : options.kontrol.startMode
      interval           : options.reportInterval
      port               : options.kontrol.port
      binary             : binaryEnabled
    }

    @workerProcess[name].connect()
    console.log "[PROCESSES][#{name}] connected to kontrold. waiting for instructions..." if verbose

    #############
    ### Start ###
    #############
    @workerProcess[name].on 'permissionToRun', =>
      # Don't create a new fork if we start it again (i.e after a stop)
      unless @list[name]?.name is name
          console.log "[PROCESSES][#{name}] received 'add' message from Kontrold. starting child_process." if verbose
          @child = @startProcess options
          @populateChildObject options, @child
          #############
          ### Child ###
          #############

          @workerProcess[name].startReporter "ack"
          @workerProcess[name].stopReporter "add"
          # Update kontrold worker information with our newly created pid.
          setTimeout =>
            @workerProcess[name].fetchWorkerExchange (workerExchange) =>
              @workerProcess[name].worker.message.command = "update"
              @workerProcess[name].worker.status = 0
              @workerProcess[name].worker.pid = @list[name].pid
              @workerProcess[name].worker.timestamp = @getDate()
              workerExchange.publish "input.worker", {worker: @workerProcess[name].worker},
                appId: "#{@workerProcess[name].worker.uuid}"
          , 5000

    #############
    ### Kill  ###
    #############
    @workerProcess[name].on 'killWorkerProcess', =>
      console.log "killing worker:", name
      @workerProcess[name].worker.status = 1
      console.log "[PROCESSES][#{name}] received 'kill' message from Kontrold. Sending SIGTERM to the child_process." if verbose
      # @child.kill 'SIGKILL' #try this in the future
      # @workerProcess[name].stopReporter() #TODO think about it
      @kill name

    @workerProcess[name].on 'killForceWorkerProcess', =>
      @disableRestart = yes
      console.log "killing worker:", name
      @workerProcess[name].worker.status = 1
      console.log "[PROCESSES][#{name}] received 'killForce' message from Kontrold. Sending SIGTERM to the child_process." if verbose
      # @child.kill 'SIGKILL' #try this in the future
      # @workerProcess[name].stopReporter() #TODO think about it
      @kill name

  populateChildObject: (options, @child) ->
    {name,onMessage,modulePath,args,restart,restartTimeout,cmd,log,onExit,stdout,stderr,verbose,die} = options
    onExit ?= ->
    console.log "[PROCESSES][#{name}] started the process: #{name} with pid: #{@child.pid}" if verbose
    @createPidFile @child.pid,name

    childObj =
      name    : name
      process : @child
      pid     : @child.pid
      verbose : verbose

    if cmd
      childObj.cmd = cmd
    else if modulePath
      childObj.fork = {modulePath,args,options}

    if @list[name]
      d = Date.now()
      console.log "[WARN][Processes] process name '#{name}' not unique. to be able to kill it properly it is now: #{name}-#{d}" if verbose
      name += "-"+d

    @list[name] = childObj

    if die?.after
      console.log "[PROCESSES][#{name}]i will kill this process:#{name} every #{die.after}msecs" if verbose
      setTimeout =>
        console.log "[PROCESSES][#{name}]it's time you die process:#{name}" if verbose
        @kill name
      ,die.after

    @child.on 'exit', ()=>
      console.log "[PROCESSES][#{name}] did exit." if verbose
      @emit "exit",@child.pid,name
      delete @list[name]
      if options.kontrol?.enabled
        @workerProcess[name].stopReporter "ack"
        @workerProcess[name].stopReporter "add"
        @workerProcess[name].connection.end()
        delete @workerProcess[name]

    @child.on 'close', () =>
      console.log "[PROCESSES][#{name}] did close." if verbose
      @emit "close",@child.pid,name
      onExit @child.pid,name
      if @disableRestart is yes
        console.log "[PROCESSES][#{name}] restart is disabled because of force mode." if verbose
        @disableRestart = no
        return

      if restart is yes
        restartTimeout = 1 unless restartTimeout
        setTimeout =>
          @run options
        ,restartTimeout
        console.log "[PROCESSES][#{name}] restarting the process in #{restartTimeout} msecs." if verbose

    @child.on 'message',(msg) =>
      onMessage msg if "function" is typeof onMessage
      if msg['process-monitor']
        delete msg['process-monitor']
        if options.kontrol?.enabled
          msg['uuid'] = @workerProcess[name].worker.uuid
          @workerProcess[name].fetchWorkerExchange (workerExchange) =>
            @workerProcess[name].worker.message.command = "ack"
            workerExchange.publish "input.worker", {monitor: msg},
              appId: "#{@workerProcess[name].worker.uuid}"

    return childObj

  createPidFile : (pid,name)->
    fs.writeFileSync "#{@childProcessesContainerDir}/#{process.pid}.#{pid}",""

  get : (name)->
    if @list[name]
      return @list[name].process
    else
      console.log "[ERROR][Processes] #{name} Can't be found."

  fetchChildren: (parentPid,callback)->
    findChildren = (arr, pid) ->
      findChildrenRec = (pid,root=yes)->
        c={}
        pid = ""+pid
        i = -1
        arr.forEach (item)->
          [parent,child] = item.split(".")
          if parent is pid
            c[child] = findChildrenRec child,no
        return c

      arr = traverse(findChildrenRec pid).paths()
      arr.forEach (group) -> group.reverse()
      arr = _.sortBy arr,(a)-> a.length*-1
      return _.uniq _.flatten arr,yes

    fs.readdir @childProcessesContainerDir,(err,list)->
      if err
        callback err
      else
        callback null,findChildren list,parentPid

  killAllChildren: (parentPid, callback) ->
    @fetchChildren parentPid,(err,orderedKillList)->
      console.log "ordered kill list:"+orderedKillList
      unless err
        pidPair = []
        orderedKillList.forEach (pid)->
          console.log "killing children: #{pid}"
          try
            pidPair.push pid
            process.kill(pid*1)
            if pidPair.length is 2
              pidPair.reverse()
              deleteFile = pidPair.join(".")
              console.log "deleting"+deleteFile
              fs.unlinkSync deleteFile
              pidPair.shift()
          catch e
            console.log "child process #{pid} did not exist. not killed by me."
        callback null

  sendMessage: (name,msg)->
    if @list[name]?.process?.send
      @list[name].process.send msg

  kill: (name,callback=->)->
    unless @list[name]
      console.log "[PROCESSES][#{name}] cant kill #{name}, couldn't find it."
    else
      pid = @list[name].pid
      console.log "[PROCESSES][#{name}] killing parent: #{pid}"
      @killAllChildren pid,(err,res)->
        console.log "[PROCESSES][#{name}] killing #{name} #{pid}"
        process.kill pid

module.exports = Processes
