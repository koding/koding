(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("__browserify_process",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
        && window.setImmediate;
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return window.setImmediate;
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    if (name === 'evals') return (require)('vm')
    else throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    process.cwd = function () { return cwd };
    process.chdir = function (dir) {
        if (!path) path = require('path');
        cwd = path.resolve(dir, cwd);
    };
})();

});

require.define("/node_modules_koding/koding-broker-client/lib/broker-client/index.js",function(require,module,exports,__dirname,__filename,process,global){
exports.Broker = require('./broker');

exports.Channel = require('./channel');

if (typeof window !== "undefined" && window !== null) {
  window['KDBroker'] = exports;
}

});

require.define("/node_modules_koding/koding-broker-client/lib/broker-client/broker.js",function(require,module,exports,__dirname,__filename,process,global){var Broker, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('microemitter').EventEmitter;

module.exports = Broker = (function(_super) {
  var Channel, NOTREADY, READY, _ref;

  __extends(Broker, _super);

  _ref = [0, 1], NOTREADY = _ref[0], READY = _ref[1];

  Channel = require('./channel');

  function Broker(ws, options) {
    this.autoReconnect = options.autoReconnect;
    this.readyState = NOTREADY;
    this.channels = {};
    this.connect(ws);
    if (this.autoReconnect) {
      this.initBackoff(options);
    }
  }

  Broker.prototype.bound = require('koding-bound');

  Broker.prototype.connect = function(ws) {
    var _ref1,
      _this = this;
    if ((_ref1 = this.ws) == null) {
      this.ws = 'string' === typeof ws ? new SockJS(ws) : ws;
    }
    this.ws.addEventListener('open', function() {
      _this.readyState = READY;
      _this.emit('ready');
      return _this.emit('connected');
    });
    this.ws.addEventListener('close', function() {
      _this.readyState = NOTREADY;
      _this.emit("disconnected", Object.keys(_this.channels));
      _this.channels = {};
      if (_this.autoReconnect) {
        return _this.setBackoffTimeout(_this.connect.bind(_this));
      }
    });
    return this.ws.addEventListener('message', this.bound('handleMessageEvent'));
  };

  Broker.prototype.disconnect = function(reconnect) {
    reconnect || (reconnect = false);
    if (!reconnect) {
      this.autoReconnect = false;
    }
    return this.ws.close();
  };

  Broker.prototype.initBackoff = function(options) {
    var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref1, _ref2, _ref3, _ref4, _ref5,
      _this = this;
    backoff = (_ref1 = options.backoff) != null ? _ref1 : {};
    totalReconnectAttempts = 0;
    initalDelayMs = (_ref2 = backoff.initialDelayMs) != null ? _ref2 : 700;
    multiplyFactor = (_ref3 = backoff.multiplyFactor) != null ? _ref3 : 1.4;
    maxDelayMs = (_ref4 = backoff.maxDelayMs) != null ? _ref4 : 1000 * 60 * 15;
    maxReconnectAttempts = (_ref5 = backoff.maxReconnectAttempts) != null ? _ref5 : 10;
    this.clearBackoffTimeout = function() {
      return totalReconnectAttempts = 0;
    };
    return this.setBackoffTimeout = function(fn) {
      if (totalReconnectAttempts < maxReconnectAttempts) {
        setTimeout(fn, Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs));
        return totalReconnectAttempts++;
      } else {
        return _this.emit("connectionFailed");
      }
    };
  };

  Broker.prototype.createRoutingKeyPrefix = function(name, isReadOnly) {
    if (isReadOnly) {
      return name;
    } else {
      return "client." + name;
    }
  };

  Broker.prototype.createChannel = function(name, isReadOnly) {
    var channel, routingKeyPrefix,
      _this = this;
    if (this.channels[name] != null) {
      return this.channels[name];
    }
    routingKeyPrefix = this.createRoutingKeyPrefix(name, isReadOnly);
    channel = new Channel(name, routingKeyPrefix, isReadOnly);
    channel.on('newListener', function(event) {
      if (event === 'broker.subscribed') {
        return _this.once(event, function(routingKeyPrefix) {
          if (routingKeyPrefix === channel.routingKeyPrefix) {
            _this.authenticate(channel);
            return channel.emit(event, routingKeyPrefix);
          }
        });
      } else {
        return _this.on("" + routingKeyPrefix + "." + event, function() {
          var rest;
          rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return channel.emit.apply(channel, [event].concat(__slice.call(rest)));
        });
      }
    });
    this.on(routingKeyPrefix, function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return channel.emit.apply(channel, ['message'].concat(__slice.call(rest)));
    });
    if (!isReadOnly) {
      channel.on('publish', function(payload) {
        var exchange, _ref1;
        exchange = (_ref1 = channel.exchange) != null ? _ref1 : channel.name;
        return _this.publish({
          exchange: exchange,
          routingKey: channel.name
        }, payload);
      });
    }
    channel.on('close', function() {
      return _this.unsubscribe(channel.name);
    });
    this.channels[name] = channel;
    return channel;
  };

  Broker.prototype.authenticate = function(channel) {
    var authInfo, key, val, _ref1;
    channel.isAuthenticated = true;
    authInfo = {};
    _ref1 = channel.getAuthenticationInfo();
    for (key in _ref1) {
      if (!__hasProp.call(_ref1, key)) continue;
      val = _ref1[key];
      authInfo[key] = val;
    }
    authInfo.routingKey = channel.routingKeyPrefix;
    return this.publish('auth', authInfo);
  };

  Broker.prototype.handleMessageEvent = function(event) {
    var message;
    message = event.data;
    this.emit('rawMessage', message);
    if (message.routingKey && message.payload) {
      this.emit(message.routingKey, message.payload);
    }
  };

  Broker.prototype.ready = function(listener) {
    if (this.readyState === READY) {
      return listener();
    } else {
      return this.on('ready', listener);
    }
  };

  Broker.prototype.send = function(data) {
    var _this = this;
    this.ready(function() {
      return _this.ws._transport.doSend(JSON.stringify(data));
    });
    return this;
  };

  Broker.prototype.publish = function(options, payload) {
    var exchange, routingKey;
    if ('string' === typeof options) {
      routingKey = exchange = options;
    } else {
      routingKey = options.routingKey, exchange = options.exchange;
    }
    routingKey = this.createRoutingKeyPrefix(routingKey);
    if ('string' !== typeof payload) {
      payload = JSON.stringify(payload);
    }
    this.send({
      action: 'publish',
      exchange: exchange,
      routingKey: routingKey,
      payload: payload
    });
    return this;
  };

  Broker.prototype.subscribe = function(name, options, callback) {
    var handler, isReadOnly, routingKeyPrefix,
      _this = this;
    if (options == null) {
      options = {};
    }
    if (this.channels[name]) {
      return this.channels[name];
    }
    isReadOnly = options.isReadOnly;
    routingKeyPrefix = this.createRoutingKeyPrefix(name, isReadOnly);
    this.send({
      action: 'subscribe',
      routingKeyPrefix: routingKeyPrefix
    });
    if (callback != null) {
      this.on('broker.subscribed', handler = function(prefix) {
        if (prefix === routingKeyPrefix) {
          _this.off('broker.subscribed', handler);
          return callback(prefix);
        }
      });
    }
    return this.channels[name] = this.createChannel(name, isReadOnly);
  };

  Broker.prototype.unsubscribe = function(name) {
    this.send({
      action: 'unsubscribe',
      routingKeyPrefix: this.createRoutingKeyPrefix(name)
    });
    return this;
  };

  return Broker;

})(EventEmitter);

});

require.define("/node_modules/microemitter/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"index.js"}
});

require.define("/node_modules/microemitter/index.js",function(require,module,exports,__dirname,__filename,process,global){var EventEmitter,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

EventEmitter = (function() {
  'use strict';

  var createId, defineProperty, idKey, init, mixin;

  idKey = 'ಠ_ಠ';

  EventEmitter.listeners = {};

  EventEmitter.targets = {};

  EventEmitter.off = function(listenerId) {
    /*
        Note: @off, but no symmetrical "@on".  This is by design.
          One shouldn't add event listeners directly.  These static
          collections are maintained so that the listeners may be
          garbage collected and removed from the emitter's record.
          To that end, @off provides a handy interface.
    */
    delete this.listeners[listenerId];
    delete this.targets[listenerId];
    return this;
  };

  defineProperty = Object.defineProperty || function(obj, prop, _arg) {
    var value;
    value = _arg.value;
    return obj[prop] = value;
  };

  createId = (function() {
    var counter;
    counter = 0;
    return function() {
      return counter++;
    };
  })();

  mixin = function(obj) {
    var prop, prot, _results;
    prot = EventEmitter.prototype;
    _results = [];
    for (prop in prot) {
      _results.push(obj[prop] = prot[prop]);
    }
    return _results;
  };

  init = function(obj) {
    if (!(idKey in obj)) {
      defineProperty(obj, idKey, {
        value: "" + (Math.round(Math.random() * 1e9))
      });
    }
    if (!('_events' in obj)) {
      return defineProperty(obj, '_events', {
        value: {}
      });
    }
  };

  function EventEmitter(obj) {
    if (obj != null) {
      mixin(obj);
    } else {
      obj = this;
    }
  }

  EventEmitter.prototype.on = function(evt, listener) {
    var lid, listeners, _base;
    if (listener == null) {
      throw new Error('Listener is required!');
    }
    init(this);
    this.emit('newListener', evt, listener);
    listeners = (_base = this._events)[evt] || (_base[evt] = {});
    if (this[idKey] in listener) {
      lid = listener[this[idKey]];
    } else {
      lid = createId();
      defineProperty(listener, this[idKey], {
        value: lid
      });
    }
    EventEmitter.listeners[lid] = listeners[lid] = listener;
    EventEmitter.targets[lid] = this;
    return this;
  };

  EventEmitter.prototype.once = function(evt, listener) {
    var wrappedListener,
      _this = this;
    wrappedListener = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.off(evt, wrappedListener);
      return listener.apply(_this, rest);
    };
    return this.on(evt, wrappedListener);
  };

  EventEmitter.prototype.when = function() {};

  EventEmitter.prototype.off = function(evt, listener) {
    var key, listenerId, listeners, _ref;
    init(this);
    switch (arguments.length) {
      case 0:
        _ref = this._events;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          delete this._events[key];
        }
        break;
      case 1:
        this._events[evt] = {};
        break;
      default:
        listeners = this._events[evt];
        listenerId = listener[this[idKey]];
        delete listeners[listenerId];
        EventEmitter.off(listenerId);
    }
    return this;
  };

  EventEmitter.prototype.emit = function() {
    var evt, id, listener, listeners, rest;
    evt = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    init(this);
    listeners = this._events[evt];
    for (id in listeners) {
      if (!__hasProp.call(listeners, id)) continue;
      listener = listeners[id];
      listener.call.apply(listener, [this].concat(__slice.call(rest)));
    }
    if (evt === 'error' && listeners.length === 0) {
      throw rest[0];
    }
    return this;
  };

  return EventEmitter;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports.EventEmitter = EventEmitter;
} else if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
  define(function() {
    return EventEmitter;
  });
} else {
  this['EventEmitter'] = EventEmitter;
}

});

require.define("/node_modules_koding/koding-broker-client/lib/broker-client/channel.js",function(require,module,exports,__dirname,__filename,process,global){var Channel, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('./microemitter').EventEmitter;

module.exports = Channel = (function(_super) {

  __extends(Channel, _super);

  function Channel(name, routingKeyPrefix, isReadOnly) {
    this.name = name;
    this.routingKeyPrefix = routingKeyPrefix;
    this.isReadOnly = isReadOnly != null ? isReadOnly : false;
  }

  Channel.prototype.publish = function() {
    var rest;
    rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this.isReadOnly) {
      return this.emit.apply(this, ['publish'].concat(__slice.call(rest)));
    }
  };

  Channel.prototype.close = function() {
    return this.emit('close');
  };

  Channel.prototype.setAuthenticationInfo = function(authenticationInfo) {
    this.authenticationInfo = authenticationInfo;
  };

  Channel.prototype.getAuthenticationInfo = function() {
    return this.authenticationInfo;
  };

  Channel.prototype.bound = require('koding-bound');

  return Channel;

})(EventEmitter);

});

require.define("/node_modules/koding-bound/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"index.js"}
});

require.define("/node_modules/koding-bound/index.js",function(require,module,exports,__dirname,__filename,process,global){module.exports = require('./lib/koding-bound');
});

require.define("/node_modules/koding-bound/lib/koding-bound/index.js",function(require,module,exports,__dirname,__filename,process,global){var __slice = [].slice;

module.exports = function() {
  var boundMethod, method, rest, _ref;
  method = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (this[method] == null) {
    return typeof this.error === "function" ? this.error("Unknown method! " + method) : void 0;
  }
  boundMethod = "__bound__" + method;
  boundMethod in this || Object.defineProperty(this, boundMethod, {
    value: (_ref = this[method]).bind.apply(_ref, [this].concat(__slice.call(rest)))
  });
  return this[boundMethod];
};

});

require.define("/node_modules_koding/koding-broker-client/index.js",function(require,module,exports,__dirname,__filename,process,global){module.exports = require('./lib/broker-client');
});
require("/node_modules_koding/koding-broker-client/index.js");
})();
