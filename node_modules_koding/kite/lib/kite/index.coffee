os = require 'os'
nodePath = require 'path'
{spawn, exec} = require 'child_process'
{Scrubber, Store} = require 'koding-dnode-protocol'
Pusher = require 'node-pusher'
request = require 'request'
express = require 'express'

log = console.log

module.exports = class Kite
  
  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @app = express.createServer()
    @app.use express.bodyParser()
    @channels = {}
    @requesters = {}
  
  unscrubMessage:(requesterId, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(requesterId+callbackId)
          @remoteStore.add requesterId+callbackId, (args...)=>
            @request unscrubbed[0].secretChannelId, callbackId, args
        @remoteStore.get requesterId+callbackId
      callback unscrubbed

  startRequestHandler:(config)->
    hostname = os.hostname()
    protocol = config.protocol or 'http://'
    port = config.port
    hostname = os.hostname()
    kiteUri = "#{protocol}#{hostname}:#{port}/"
    logfile = config.requestHandler.logfile or '/tmp/kite-request-handler.log'
    joinedChannelsDir = config.requestHandler.joinedChannelsDir or '/tmp/joined-channels-file/'
    requestHandlerPath = config.requestHandler.path or nodePath.join(
      nodePath.dirname(module.filename)
      'lib/request-handler'
    )
    cmd = [
      "cd #{requestHandlerPath} &&"
      'ruby index.rb'
      '-k', config.pusher.key
      '-s', config.pusher.secret
      '-l', logfile
      '-u', kiteUri
      '-n', @kiteName
      '-j', joinedChannelsDir
    ].join ' '
    console.log cmd
    requestHandler = exec cmd
    requestHandler.stdout.on 'data', (data)-> log 'DATA:', data
    requestHandler.stderr.on 'data', (data)-> log 'ERROR:', data
    requestHandler.on 'exit', (code)=>
      log "REQUEST HANDLER PROCESS EXITED WITH CODE #{code}"
      setTimeout (=> @startRequestHandler config), 1000
    process.on 'exit', -> requestHandler.kill()

  handleRequest:(data, res, config)->
    # log @kiteName, 'HANDLING REQUEST on behalf of', data.username, data
    res.header 'Content-type', 'text/javascript'
    {channels, requesters} = @
    try
      scrubbed = JSON.parse data.data
      requesterId = data.username
    catch e then return res.send error: 400
    @unscrubMessage requesterId, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      {method, withArgs, secretChannelId, subscriberCount, callbackId} = data
      withArgs or= {}
      withArgs.username = requesterId
      channel = "private-#{@kiteName}-#{requesterId}" 
      if method isnt '_disconnect' and not requesters[requesterId]?
        # send the _connect message to this kite's user-defined API.
        @api._connect? {requesterId}
        # make sure the request handler daemon is listening to client events.
        if config.requestHandler?.isEnabled
          @pusher
            .trigger("private-krh-#{@kiteName}", 'join', {channel})
            .trigger(channel, 'changeTransport', transport: 'mq')
        requesters[requesterId] = {}
      switch method
        when '_handleCallback'
          kallback = @localStore.get scrubbed.method
          kallback? withArgs...
          return res.send result: 200
        when '_disconnect'
          if requesters[requesterId]?
            Object.keys(requesters[requesterId]).forEach (channelId)->
              delete channels[channelId] if --channels[channelId] is 0
            @api._disconnect? {
              requesterId
              channels: requesters[requesterId]
            }
            if config.requestHandler?.isEnabled
              @pusher.trigger("private-krh-#{@kiteName}", 'part', {channel})
            delete requesters[requesterId]
            return res.send result: 200
          else return res.send error: 400
        when '_ping' then return res.send result: 200
        else
          if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
            channels[secretChannelId] ?= 0
            channels[secretChannelId] += 1
            requesters[requesterId][secretChannelId] = yes
            withArgs.requesterId = requesterId
            @api[method]? withArgs, (err, msg)=>
              if channels[secretChannelId]?
                scrubber = new Scrubber @localStore
                scrubber.scrub [].slice.call(arguments), =>
                  out = scrubber.toDnodeProtocol()
                  out.method = callback.id
                  @pusher.trigger secretChannelId, 'message', out
            return res.send result: 200
          else
            return res.send error: 400
  
  handleRequests:(config)->
    @app.post '/', (req, res)=>
      @handleRequest req.body, res, config
    @app.get '/', (req, res)=>
      @handleRequest req.query, res, config
  
  registerSelf:->
    uri = @apiUri+'/kite/connect'
    console.log 'Connecting to the API server:', uri
    request.get {
      uri     : uri
      qs      : 
        data  : JSON.stringify {
          @kiteName
          uri : @protocol+os.hostname()+':'+@port
        }
    }, (err, response, body)->
      console.log 'Received a response from the API server:', body
  
  request:(secretChannelId, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      @pusher.trigger secretChannelId, 'message', out
  
  run:(config)->
    {port,pidPath,logPath,protocol,@apiUri} = config
    @pusher = new Pusher config.pusher
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
    @protocol = protocol or 'http://'
    @port = port
    @app.listen port
    @startRequestHandler(config) if config.requestHandler?.isEnabled
    @handleRequests(config)
    @registerSelf()
