
module.exports = (context)->
  if 'function' is typeof context
    if context.name
      # we're returning a subclass of the provided context
      # our subclass is the future layer
      class Future extends context

        @queue or= []

        constructor:->
          @queue = []
          super

        initializeFuture.call @
    else
      # we're marking a function to be "future", so that it will receive
      # the pipeline and magic next callback
      context.isFuture = yes
      context

initializeFuture = do ->

  { filter, methods } = require 'underscore'
  { slice } = []

  Pipeline = require './pipeline'

  originalMethods = {}

  method =(context, methodName)->
    originalMethods[methodName] = context[methodName]
    ->
      @queue.push {
        context
        methodName
        args: slice.call arguments
      }
      @

  next =(pipeline, err)->
    if err?
      pipeline.callback.call @, err
    else
      queued = pipeline.queue.shift()
      if queued?
        { methodName, context, args } = queued
        args.unshift pipeline
        args.push next.bind @, pipeline
        try
          originalMethods[methodName] args...
        catch e
          pipeline.callback.call @, e, pipeline
      else
        pipeline.callback.call @, null, pipeline

  andThen =(callback)->
    pipeline = new Pipeline [], @queue, callback
    if pipeline.queue.length
      next.call @, pipeline
    # TODO: should pipelines execute with a noop
    # callback on the next tick if they aren't acted upon?
    @queue = []
    @

  # andWhile = future (fn)->
  #
  # andFor = future (fn)->
  #
  # andIf = future (fn)->
  #
  # andElseIf = future (fn)->
  #
  # andElse = future (fn)->
  #
  # end =->

  isFuture =(methodName)->
    @[methodName].isFuture

  replaceMethods =->
    for methodName in filter (methods @), isFuture.bind @
      @[methodName] = method @, methodName
    @then = andThen
    # @while = andWhile
    # @for = andFor
    #
  ->
    replaceMethods.call @
    replaceMethods.call @::
