
module.exports = (context) ->
  if 'function' is typeof context
    if context.name
      # we're returning a subclass of the provided context
      # our subclass is the future layer
      class Future extends context

        @queue or= []

        constructor: ->
          @queue = []
          super

        initializeFuture.call this
    else
      # we're marking a function to be "future", so that it will receive
      # the pipeline and magic next callback
      context.isFuture = yes
      context

initializeFuture = do ->

  { filter, methods } = require 'underscore'
  { slice } = []

  Pipeline = require './pipeline'

  originalMethods = {}

  method = (context, methodName) ->
    originalMethods[methodName] = context[methodName]
    ->
      @queue.push {
        context
        methodName
        args: slice.call arguments
      }
      this

  next = (pipeline, err) ->
    if err?
      pipeline.callback.call this, err
    else
      queued = pipeline.queue.shift()
      if queued?
        { methodName, context, args } = queued
        args.unshift pipeline
        args.push next.bind this, pipeline
        try
          originalMethods[methodName] args...
        catch e
          pipeline.callback.call this, e, pipeline
      else
        pipeline.callback.call this, null, pipeline

  andThen = (callback) ->
    pipeline = new Pipeline [], @queue, callback
    if pipeline.queue.length
      next.call this, pipeline
    # TODO: should pipelines execute with a noop
    # callback on the next tick if they aren't acted upon?
    @queue = []
    this

  # andWhile = future (fn) ->
  #
  # andFor = future (fn) ->
  #
  # andIf = future (fn) ->
  #
  # andElseIf = future (fn) ->
  #
  # andElse = future (fn) ->
  #
  # end = ->

  isFuture = (methodName) ->
    @[methodName].isFuture

  replaceMethods = ->
    for methodName in filter (methods this), isFuture.bind this
      this[methodName] = method this, methodName
    @then = andThen
    # @while = andWhile
    # @for = andFor
    #
  ->
    replaceMethods.call this
    replaceMethods.call this::
