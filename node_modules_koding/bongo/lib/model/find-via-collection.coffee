{ castAll } = require '../util'

module.exports = helpers =

  drop:(collection, callback) -> collection.drop callback

  update:(collection, selector, operation, options, callback) ->
    [callback, options] = [options, callback]  unless callback
    options or= {}
    options.safe = yes
    callback ?= ->
    collection.update selector, operation, options, callback

  findAndModify:(collection, rest...) -> collection.findAndModify rest...

  one:(collection, uniqueSelector, options, callback) ->
    [callback, options] = [options, callback]  unless callback
    options ?= {}
    konstructor = this
    collection.findOne castAll(uniqueSelector, konstructor), options, (err, doc) ->
      model = if not err and doc then new konstructor doc
      callback err, model
    return this

  all:(collection, selector, callback) ->
    konstructor = this
    collection.find castAll(selector, konstructor), (err, cursor) ->
      if err
        callback err
      else
        cursor.toArray (err, docs) ->
          if err then callback err
          else callback null, docs?.map (doc) ->
            new konstructor doc
    return this

  remove:(collection, selector, callback) ->
    [callback, selector] = [selector, callback]  if 'function' is typeof selector
    selector ?= {}
    callback ?= (->)
    konstructor = this
    collection.remove castAll(selector, konstructor), { safe:yes }, callback
    return this

  count:(collection, selector, callback) ->
    [callback, selector] = [selector, callback]  unless callback
    selector or= {}
    konstructor = this
    collection.count castAll(selector, konstructor), callback
    return this

  aggregate:(collection, rest..., callback) ->
    collection.aggregate rest..., callback
    return this

  some:(collection, selector, options, callback) ->
    konstructor = this
    delete options[name]  for own name of options when not options[name]?
    collection.find castAll(selector, konstructor), null, options, (err, cursor) ->
      if err
        callback err
      else
        cursor.toArray (err, docs) ->
          callback null, docs?.map (doc) -> new konstructor doc
    return this

  someData:do ->
    ###
    @class: CursorDelegate
    @description: creates a proxy for a given cursor that has
      the critical methods bound as own-properties, which is
      handy for sharing the cursor with the client over dnode.
    ###
    class CursorDelegate
      methodNames = ['nextObject', 'each', 'toArray']
      constructor:(skinCursor) ->
        { @totalNumberOfRecords } = skinCursor
        for methodName in methodNames
          @[methodName] = skinCursor[methodName].bind skinCursor
    ###
    @implementation.
    ###
    (collection, selector, fields, options, callback) ->
      [options, callback] = [callback, options]  unless callback
      options or= {}
      konstructor = this
      selector = castAll(selector, konstructor)
      collection.find selector, fields, options, (err, cursor) ->
        callback err, if cursor then new CursorDelegate cursor
      return this

  cursor:do ->
    ModelCursor = require '../modelcursor'
    (collection, selector, options, callback) ->
      [callback, options] = [options, callback]  unless callback
      options ?= {}
      helpers.someData.call this, collection, selector, {}, options, (err, cursor) =>
        callback err, unless err then new ModelCursor cursor, this

  each:(collection, selector, fields, options, callback) ->
    [options, callback, fields] = [fields, options, callback]  unless callback
    kallback = (err, cursor) ->
      if err then callback err
      else cursor.each callback
    if fields?
      helpers.someData.call this, collection, selector, fields, options, kallback
    else
      helpers.cursor.call this, collection, selector, options, kallback

  hose:(rest...) ->
    helpers.someData.call this, rest...
