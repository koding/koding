# lib
{ castAll } = require '../util'

helpers = require './find-via-collection'

###
@mixin: bongo "find" methods.
@description: Methods for selecting against the model's
  MongoDB collection.  You can mix this into constructors
  that have static methods with all of the following:
  @requiredSignature: SkinCollection obj.getCollection()
  @requiredSignature: obj.castValue(selector, constructor)
###
module.exports =

  drop:(callback) ->
    helpers.drop.call this, @getCollection(), callback

  update:(selector, operation, options, callback) ->
    helpers.update.call this, @getCollection(), selector, operation, options, callback
    return this

  findAndModify:(rest...) ->
    helpers.findAndModify.call this, @getCollection(), rest...
    return this

  assure:(selectorOrInitializer, callback) ->
    constructor = this
    @one selectorOrInitializer, (err, inst) ->
      if err
        callback err
      else if inst
        callback null, inst
      else
        callback null, new constructor selectorOrInitializer
    return this

  one:(uniqueSelector, options, callback) ->
    helpers.one.call this, @getCollection(), uniqueSelector, options, callback
    return this

  oneData:(uniqueSelector, fields, options, callback) ->
    [callback, options] = [options, callback]  unless callback
    helpers.someData.call this, @getCollection(), uniqueSelector, fields, options, (err, cursor) ->
      return callback err  if err
      cursor.nextObject (err, doc) ->
        return callback err  if err
        callback null, doc
    return this

  all:(selector, callback) ->
    helpers.all.call this, @getCollection(), selector, callback
    return this

  remove:(selector, callback) ->
    helpers.remove.call this, @getCollection(), selector, callback
    return this

  removeById:(_id, callback) ->
    @remove { _id }, callback

  count:(selector, callback) ->
    helpers.count.call this, @getCollection(), selector, callback
    return this

  aggregate:(rest..., callback) ->
    helpers.aggregate.call this, @getCollection(), rest..., callback
    return this

  some:(selector, options, callback) ->
    helpers.some.call this, @getCollection(), selector, options, callback
    return this

  someData:(selector, fields, options, callback) ->
    helpers.someData.call this, @getCollection(), selector, fields, options, callback
    return this

  cursor:do ->
    ModelCursor = require '../modelcursor'
    (selector, options, callback) ->
      [callback, options] = [options, callback]  unless callback
      options ?= {}
      @someData selector, {}, options, (err, cursor) =>
        callback err, unless err then new ModelCursor cursor, this

  each:(selector, fields, options, callback) ->
    [options, callback, fields] = [fields, options, callback]  unless callback
    kallback = (err, cursor) ->
      if err then callback err
      else cursor.each callback
    if fields?
      @someData selector, fields, options, kallback
    else
      @cursor selector, options, kallback

  hose:(rest...) -> @someData {}, rest...

  mapReduce:(map, reduce, options, callback) ->
    [callback, options] = [options, callback]  unless callback
    options or= {}
    { wrapData } = options
    options.out or= { inline: 1 }
    delete options.wrapData
    constructor = this
    collection = @getCollection()
    collection.mapReduce map, reduce, option, (err, collection) ->
      collection.find (err, cursor) ->
        cursor.toArray (err, docs) ->
          callback \
            unless wrapData then docs
            else docs?.map (doc) -> new constructor doc
    this
