
module.exports = helpers =
  ###
  @method.
  @signature: Model::save(callback)
  @param: callback
  @description: save this model to its collection, or notify
    its parent that it should be saved, in the case of embedding.
  ###
  save: (callback)->
    model = @
    model.applyDefaults(model.isRoot_)
    collection = model.getCollection()
    model.validate helpers.save_0_.bind model, callback, collection
    model
      #else if isNew
  ###
  @function. bound to the model instance
  @signature: save_0_.bind(model, callback)
  @param: model - to bind the function to
  ###
  save_0_:(callback, collection, err)->
    {ObjectId} = require '../'
    model = @
    if err?
      callback? err
    else if model.isRoot_
      unless model.data._id?
        data = model.get yes
        delete data.bongo_
        model._id = data._id = new ObjectId
        collection.insert data, (safe:yes), helpers.save_1_.bind model, callback, yes
      else
        # TODO: implement atomic updates
        data = model.get yes
        delete data._id
        delete data.bongo_
        collection.update \
          (_id: do model.getId), data,
          (safe:yes), helpers.save_1_.bind model, callback, no
    else
      model.rootNode_?.saveAtomically model, callback
  ###
  @function. bound to the model instance
  @signature: save_1_.bind(model, callback)
  @param: model - to bind the function to
  ###
  save_1_:(callback, isNew, err, results)->
    model = @
    {constructor} = model
    unless err
      { ops: docs } = results
      if id = docs[0]?._id
        model.data._id = id
      if constructor.feedable is true or constructor.feedable?.call? model
        constructor.appendToFeed model, if isNew then 'new' else 'update'
    callback?.call model, err, docs, isNew
    @emit 'save'
