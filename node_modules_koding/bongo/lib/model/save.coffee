
module.exports = helpers =
  ###
  @method.
  @signature: Model::save(callback)
  @param: callback
  @description: save this model to its collection, or notify
    its parent that it should be saved, in the case of embedding.
  ###
  save: (callback) ->
    model = this
    model.applyDefaults(model.isRoot_)
    collection = model.getCollection()
    model.validate helpers.save_0_.bind model, callback, collection
    model
      #else if isNew
  ###
  @function. bound to the model instance
  @signature: save_0_.bind(model, callback)
  @param: model - to bind the function to
  ###
  save_0_:(callback, collection, err) ->
    { ObjectId } = require '../'
    model = this
    if err?
      callback? err
    else if model.isRoot_
      unless model.data._id?
        data = model.get yes
        delete data.bongo_
        model._id = data._id = new ObjectId
        collection.insert data, ({ safe:yes }), helpers.save_1_.bind model, callback, yes
      else
        # TODO: implement atomic updates
        data = model.get yes
        delete data._id
        delete data.bongo_
        collection.update \
          ({ _id: do model.getId }), data,
          ({ safe:yes }), helpers.save_1_.bind model, callback, no
    else
      model.rootNode_?.saveAtomically model, callback
  ###
  @function. bound to the model instance
  @signature: save_1_.bind(model, callback)
  @param: model - to bind the function to
  ###
  save_1_:(callback, isNew, err, results) ->
    model = this
    { constructor } = model
    unless err
      { ops: docs } = results
      if id = docs[0]?._id
        model.data._id = id
    callback?.call model, err, docs, isNew
    @emit 'save'
