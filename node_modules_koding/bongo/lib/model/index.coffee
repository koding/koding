# coffeelint: disable=cyclomatic_complexity

###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@class: Model
@description: A class for modeling, validating,
  transforming, saving, finding and sharing data.
  The model klass of the library.
@author: Christopher Thorn <chris@koding.com>
###
Base = require '../base'
module.exports = class Model extends Base
  ###
  @dependencies.
  ###
  # core
  { inspect } = require 'util'
  # contrib
  mongo     = require 'mongodb'
  Traverse  = require 'traverse'
  { extend, clone } = require 'underscore'
  MongoOp = require 'mongoop'
  { sequence }    = require 'sinkrow'
  Inflector       = require 'inflector'
  # lib
  JsPath          = require '../jspath'
  ObjectId        = require '../objectid'
  Subcollection   = require '../subcollection'
  Validator       = require '../validator'
  # err
  { SchemaError, IndexError } = require '../errortypes'
  ###
  @vars.
  ###
  # defineProperty
  { defineProperty } = Object
  # native JS casts
  primitives = [
    String
    Number
    Boolean
  ]
  # native JS constructors
  natives = [
    Object
    RegExp
    Date
  ]


  @inCollectionBySource = -> return this # this is a stub

  ###
  @method: property of the constructor
  @signature: Model.setDontAutoCastId(true|false)
  @description: By default, bongo will automatically cast strings
    that it finds inside a field called "_id" as BSON ObjectIds.
    This works great for most cases, and adds a layer of convenience
    (you don't need to import ObjectId and manually cast the value),
    but could potentially be problematic if you want to store another
    type of value in the "_id" field, which MongoDB doesn't prohibit
    you from doing.  In that case, set this flag to true (directly,
    or by invoking this method with the parameter "true").
  ###
  @setDontAutoCastId = (@dontAutoCastId = false) ->
  ###
  @method: property of the constructor
  @signature: setValidators(validators)
  @todo: implement
  ###
  @setValidators = (validators) ->
  ###
  @method: property of the constructor
  @signature: setBricks(validators)
  @todo: implement
  ###
  @setBricks = (bricks) ->
  ###
  @method: property of the constructor
  @signature: Model.setClient(*overload)
  @overload:
    @signature: Model.setClient(client)
    @param: client - an instance of the Db constructor from mongodb native.
  @overload:
    @signature: Model.setClient(url)
    @param: url - of the mongodb.
  @overload:
    @signature: Model.setClient(options)
    @param: options - initializer for the connetion.
    @options:
      - server
      - username
      - password
      - database
      - port
  @return: the constuctor
  @description: basically, it registers a connection with the Model
    class for the purpose of saving and finding data.
  @todo: do we want an instance method that will allow certain instances
    to have their own separate connection?  It is convenient to have this
    registered at the class-level, for obvious reasons.  It is maybe too
    abstract, tho.
  ###
  @setClient = do ->

    setClientHelper = (client) ->
      client
        .on 'close',      => @emit 'dbClientDown'
        .on 'reconnect',  => @emit 'dbClientUp'

      if @client_?
        constructor.client_ = client

      else
        defineProperty this, 'client_',
          value: client
          writable: yes


      unless Model.client_?
        Model.setClient client


    (overload, shouldConnect = yes) ->

      if overload instanceof mongo.Db
        setClientHelper this, overload

      else
        connStr =
          if 'string' is typeof overload then overload
          else
            { server, username, password, database, port } = overload
            auth = if username and password then "#{username}:#{password}@" else ''
            # TODO: this is obviously botched ^.
            connStr = "mongodb://#{auth}#{server}:#{port}/#{database}"

        mongo.MongoClient.connect connStr, (err, db) =>
          throw err  if err?

          setClientHelper.call this, db
          @emit 'dbClientReady'


  @getClient = -> @client_ or Model.client_

  @getCache = -> @cache_ or Model.cache_

  @setCache = (cache) ->

    if @cache_?
      constructor.cache_ = cache
    else
      defineProperty this, 'cache_',
        value: cache
        writable: yes

    Model.setCache cache  unless Model.cache_?

  @setCollectionName = (@collection_) ->

  @getCollectionName = ->
    @collection_ or= Inflector.decapitalize Inflector.pluralize @name

  @getCollection = ->
    client = @getClient()
    unless client
      throw new Error \
        '''
        You must set the database client for this constructor, or failing that, you must set a generic client for Model.
        '''
    client.collection @getCollectionName()

  getCollection: -> @constructor.getCollection()

  ###
  @method: property of the constructor.
  @signature: Model.setIndexes([indexes][, callback])
  @return: the constructor.
  ###
  @setIndexes = do ->
    ###
    @vars.
    @description: index orientation fudge tests
    ###
    ascending_  = /^(asc|ascending|1)$/i
    descending_ = /^(desc|descending|-1)$/i

    construeOrientation = (attr) ->
      attr = String(attr).toLowerCase()
      if ascending_.test attr then 1
      else if descending_.test attr then -1
      else 0

    (indexes, callback) ->
      @indexes_ = indexes
      if 'function' is typeof indexes
        [callback, indexes] = [indexes, callback]
      constructor = this
      if indexes
        defineProperty constructor, 'indexes', { value: indexes }
      else
        { indexes } = constructor
      unless indexes
        throw new Error \
          '''
          No indexes were provided.  (At least one is required.)
          '''
      figureIndex = sequence (collection, key, attrs, next) ->
        field = {}
        def = {}
        field[key] = null
        if 'string' is typeof attrs
          attrs = [attrs]
        for attr in attrs
          if orientation = construeOrientation attr
            field[key] = orientation
          else
            def[attr] = yes
        field[key] or= 1
        # ensure the index
        collection.ensureIndex field, def, (err) ->
          next? err
          return
        return
      , callback
      Model.on 'dbClientReady', ->
        collection = constructor.getCollection()
        for own key, attrs of indexes
          figureIndex collection, key, attrs
        return
      constructor

  ###
  @method: property of the constructor.
  @signature: Model.setSchema(schema)
  ###
  @describeSchema = ->

    { types, descriptions, schema } = this

    (Object.keys types ? {})
      .map (slot) ->

        type  = types[slot].name
        items = null

        slot = slot.replace /\.0$/, ->
          items = { type }
          type = 'Array'
          return ''

        props = { type }
        props.items = items  if items

        description = descriptions[slot]
        props.description = description  if description

        required = !!schema[slot]?.required
        props.required = required  if required

        return [slot, props]

      .reduce (acc, [slot, props]) ->
        slot = slot.replace /\.type$/, ''
        JsPath.setAt acc, slot, props
        return acc

      , {}

  ###
  @method: property of the constructor.
  @signature: Model.setSchema(schema)
  @param: schema - ^3
  @return: the constructor.
  @description: sets a constructor property "schema"^3. sets constructor
    properties for each memo to help quicken traversal of important paths
    (without walking the entire schema).
  ###
  @setSchema = (schema) ->
    if this is Model
      throw new SchemaError "Don't define a schema for Model, which is abstract."
      # track a reference to the constructor so we can look it up by name.
    constructor = this
    defineProperty constructor, 'validators_',
      value: clone Validator.inbuilts
    # store a reference to the human-readable schema
    defineProperty constructor, 'schema',
      value: schema
    # memoize the important bits for easy lookup
    for own memoName, memo of constructor.getMemosOf schema
      defineProperty constructor, memoName,
        enumerable: yes
        value: memo
    this

  @attachCacheFunc = (field) ->
    name = @getInterfaceName 'fetchFromCacheBy', field, no

    @[name] = (_field, callback) ->
      if cache = @getCache()
        cacheKey = "#{@name}_#{field}_#{_field}"
        value = cache.get cacheKey
        return callback null, value if value

      selector = {}
      selector[field] = _field

      @one selector, (err, data) =>
        return callback err if err
        for cacheableField in @cacheableFields
          key = "#{@name}_#{cacheableField}_#{data[cacheableField]}"
          cache.set key, data

        return callback null, data

  ###
  @method: property of the constructor.
  @signature: Model.getMemosOf(schema)
  @param: schema - ^3
  @return: the map of memos by path.
  @description: walk over the schema, interpreting it along the way
    and finding the notable items and annotations, and mapping memos
    of them by their paths; then return the maps of all the memos by
    by path by memo name.
  @todo: this implementation is really long.
  ###
  accessorNames = ['get', 'set']
  @getMemosOf = (schema) ->
    constructor = this
    memos =
      paths               : {}
      filters             : {}
      types               : {}
      descriptions        : {}
      subcollections      : {}
      subcollectionEmbeds : {}
      validators          : {}
      annotations         : {}
      primitives          : {}
      natives             : {}
      embeds              : {}
      oids                : {}
      defaults            : {}
      setters             : {}
      getters             : {}
      accessorParents     : {}
      rootProperties      : []
      cacheableFields     : []
    new Traverse(schema)
      .forEach ->
        { node, path } = this
        pathName = path.join '.'
        memos.paths[pathName] = yes # this path exists in the schema
        if path.length is 1
          if path[0] is 'globalFlags' then #console.log node
          memos.rootProperties.push pathName
        if 'function' isnt typeof node
          if Array.isArray node
            unless node.length is 1 and 'function' is typeof node[0]
              throw new SchemaError \
                """
                Can't interpret #{constructor.name}.schema.#{pathName}.
                """
            else
              memos.subcollections[pathName] = node[0]
          else if 'function' is typeof node.type #^5
            # type is a described by the "type" property
            # this opens the doorway for some more complex (than type-only) annotations
            @update node, yes # we don't want to traverse any deeper into this thing.
            type = node.type
            if node.cacheable
              memos.cacheableFields.push pathName
              constructor.attachCacheFunc pathName

            if node.default?
              memos.defaults[pathName] = node.default
            if node.filter?
              memos.filters[pathName] = node.filter
            # TODO: implement leaf-level broadcastChanges
            # memos.broadcastChanges[pathName] =
            #   if node.broadcastChanges?
            #     node.broadcastChanges
            #   else yes
            # memoize any validators
            leafValidators = []
            for own validatorName, validator of constructor.validators_
              options = node[validatorName]
              if options?
                leafValidators.push new Validator validatorName, validator, options
            # memoize validators:
            if leafValidators.length
              memos.validators[pathName] = leafValidators
            # memoize any accessors:
            for accessor in accessorNames
              if node[accessor]
                unless 'function' is typeof node[accessor]
                  throw new SchemaError \
                    """
                    "#{accessor}" is not a function
                    """
                memos["#{accessor}ters"][path] = node[accessor]
                accessorParentPath = ['_data'].concat path.slice 0, -1
                parent = memos.accessorParents[accessorParentPath.join '.'] or= []
                parent.push path unless path in parent
        else if node.name #^4
          type = node
        # memoize any annotations
        return unless type
        memos.descriptions[pathName] = node._description ? null
        memos.types[pathName] = type
        if type is ObjectId
          memos.oids[pathName] = type
        else if type in primitives
          memos.primitives[pathName] = type
        else if type in natives
          memos.natives[pathName] = type
        else
          memos.annotations[pathName] = type
          chain = type.inheritanceChain?()
          if chain and Model in chain
            isSubcollectionType = path.slice(-1)[0] is '0'
            if isSubcollectionType
              memos.subcollectionEmbeds[path.slice(0, -1).join '.'] = type
            else
              memos.embeds[pathName] = type
        return # we don't want to implicitly return anything from the above if-ladder
    memos
  ###
  @method: property of the constructor.
  @signature: Model.getType(model, path)
  @param: model - that we're searching
  @param: path - that we're searching for
  @description: returns the type (the cast function or constructor)
    that correlates to the given path of the given model.
  @todo: reimplement. for now this will work, but it's a bit ugly,
    and it probably performs badly relative to the optimal.
  ###
  @getType = (model, path) ->
    { constructor } = model
    { types } = constructor
    return unless types
    if type = types[path.join '.']
      return type
    else
      path = path.slice()
      tryPath = []
      while component = path.shift()
        tryPath.push component
        if type = types[tryPath.join '.']
          ref = type
          continue
        chain = ref?.inheritanceChain?()
        if chain and Model in chain
          path.push tryPath.pop()
          return Model.getType JsPath.getAt(model.data, tryPath), path
    return

  ###
  @method: property of the constructor.
  @signature: Model.castValue(value, type)
  @param: value - to be cast.
  @param: type - for the value to be cast as.
  @return: the casted value
  ###
  @castValue = (value, type) ->
    unless type? then # console.log '[WARN] castValue is called without a type.'
    else if type is Array then return value # special case this for mongo's special case
    else if type is Object or
            type is RegExp or
            type in primitives
      type value
    else if value instanceof type
      return value
    else if type is ObjectId or type is Date
      try
        new type value
    else
      chain = type.inheritanceChain?()
      if chain and Model in chain
        if value instanceof type
          value
        else
          new type value
      else if type
        throw new TypeError \
          """
          Don't know how to cast value of type "#{value.constructor.name}"
          to type "#{type.name}".
          """

  ###
  Querying
  @description: see ./find.coffee for detailed explanations.
  ###
  {
    @one, @all, @some, @someData, @remove, @removeById, @drop, @cursor, @findAndModify,
    @count, @aggregate, @teasers, @hose, @mapReduce, @assure, @update, @each
  } = require './find'

  ###
  Model::fetchIdBySlug
  ###
  @fetchIdBySlug = (slug, callback) ->
    @someData { slug }, { _id:1 }, { limit:1 }, (err, cursor) ->
      if err then callback err
      else
        cursor.nextObject (err, doc) ->
          if err then callback err
          else unless doc?
            callback new Error "Unknown slug: #{slug}"
          else
            callback null, doc._id

  ###
  @constructor.
  @signature: new Model(data)
  @param: data - with which to initialize the new instance.å
  @description: create a new Model instance.
  ###
  constructor:(data = {}) ->
    super data

    model = this

    defineProperty model, 'isNew',
      value     : yes
      writable  : yes
    defineProperty model, 'defaults', { value: {} }
    defineProperty model.defaults, 'beenApplied',
      value     : no
      writable  : yes
    defineProperty model, 'data',
      value: {}
      enumerable: yes
    # allow a maximum of 1 parent to be specified per model
    # TODO: perhaps we can introduce multidimensionality, but
    # of course it is a logical impossibility when it comes
    # to embedding.
    parent = null
    defineProperty model, 'parent_', { writable: yes }
    # Allow a model to know its path:
    defineProperty model, 'path_', { writable: yes }
    # Root node:
    defineProperty model, 'rootNode_', { writable: yes }
    defineProperty model, 'isRoot_',
      value: yes
      writable: yes
    # Support embedding models directly:
    isEmbedded_ = no
    defineProperty model, 'isEmbedded_',
      set :(value) -> isEmbedded_ = value
      get : -> isEmbedded_
    # Support embedding models into "subcollections":
    inSubcollection_ = no
    defineProperty model, 'inSubcollection_',
      set :(value) -> inSubcollection_ = isEmbedded_ = yes
      get : -> inSubcollection_
    # we need a place to store "setter values"
    defineProperty model, 'setterValues', { value: {} }
    for own parentPath, paths of model.constructor.accessorParents
      model.defineAccessorsOf parentPath.split('.').slice(1), paths
    for prop in model.constructor.rootProperties
      defineRootAccessorOf_ model, prop
    # import the data, casting values and constructing objects, as appropriate:
    model.set data
    # initialize any embedded docs.
    model.initEmbeds()

  clone: -> new @constructor @data

  ###
  @function.
  @signature: defineRootAccessorOf_(model, propertyName)
  @param: model
  @param: prop - the property name
  ###
  defineRootAccessorOf_ = (model, prop) ->
    { data, defaults } = model
    unless prop of model
      defineProperty model, prop,
        enumerable: yes
        get : ->
          if data[prop]?
            data[prop]
          else
            #model.applyDefaults()
            data[prop] = defaults[prop]
        set :(value) ->
          data[prop] = value
  ###
  @method.
  @signature: Model::defineAccessorsOf(parentPath, paths)
  @param: parentPath - an array of the segments of the path
    drilling down to, but not including the accessor itself
  @param: paths - an array of the complete paths of setters
    redundant, but convenient. this may change.
  @return: model
  @description: returns a structure object that has all
    accessors predefined.
  ###
  defineAccessorsOf:(parentPath, paths) ->
    model = this
    { data } = model
    unless parentPath.length
      parent = data
    else
      parent = JsPath.getAt(data, parentPath) or {}
      JsPath.setAt data, parentPath, parent
    for path in paths
      assignAccessorsByPath_ model, data, parent, path #^* see below.
    this
  ###
  @function.
  @signature: assignAccessorsByPath_(model, data, parent, path)^*
  @param: model - the instance.
  @param: data - the working tree.
  @param: parent - the owner of the properties we're setting.
  @param: path - the full path of the property we're setting.
  @description: a helper function for Model.defineAccessorsOf()
    so we don't create functions in the loop. (see above ^*)
  ###
  assignAccessorsByPath_ = (model, data, parent, path) ->
    pathName = path.join '.'
    prop = path.slice(-1)[0]
    setter = model.constructor.setters[pathName]
    getter = model.constructor.getters[pathName]
    defineProperty parent, prop,
      enumerable : yes
      set :(value) ->
        if setter
          value = setter.call parent, value #^**
        model.setterValues[pathName] = value
      get : ->
        value = model.setterValues[pathName]
        if getter
          value = getter.call parent, value #^**
        value
      # ** call accessors in the context of the parent so that
      # "this" is meaningful.
  ###
  @method.
  @signature: Model::applyDefaults()
  @param: callback
  @return: the model.defaults object
  @description: apply all the defaults throughout the model.
    call .applyDefaults() on any embedded models encountered
    in the walk.
  ###
  applyDefaults:(isDeep = no) ->
    model = this
    if model.defaults? and not model.defaults.beenApplied
      # set default values for all fields
      for own defaultPath, defaultValue of model.constructor.defaults
        if 'function' is typeof defaultValue
          defaultValue = defaultValue.call model
        JsPath.setAt model.defaults, defaultPath, defaultValue
      model.defaults.beenApplied = yes
    if isDeep
      for own embedPath, embedConstructor of model.constructor.embeds
        JsPath.getAt(model, embedPath)?.applyDefaults()
      for own subcollectionEmbedPath, subcollectionEmbedAnnotation of model.constructor.subcollectionEmbeds
        JsPath.getAt(model, subcollectionEmbedPath)?.forEach (embed) ->
          embed.applyDefaults()
    model

  ###
  @method.
  @signature: Model::initEmbeds()
  @description: rather a heavy function that will initialize
    embedded models and embedded subcollections.  Separated this
    from .applyDefaults(), because the latter should be fleet.
  ###
  initEmbeds: ->
    model = this
    # initialize any models that are undefined.
    for own embedPath, embedConstructor of model.constructor.embeds
      embedPath = embedPath.split '.'
      unless JsPath.getAt(model.data, embedPath)?
        embed = new embedConstructor
        embed.path_ = embedPath
        embed.parent_ = JsPath.getAt model, embedPath.slice 0, -1
        JsPath.setAt model.defaults, embedPath, embed
    # initialize any subcollections
    for own subcollectionEmbedPath, subcollectionEmbedAnnotation of \
      model.constructor.subcollectionEmbeds
        subcollectionEmbedPath = subcollectionEmbedPath.split '.'
        unless JsPath.getAt(model.data, subcollectionEmbedPath)?
          parent = JsPath.getAt model, subcollectionEmbedPath.slice 0, -1
          subcollection = new Subcollection \
            parent, [], subcollectionEmbedAnnotation
          subcollection.path_ = subcollectionEmbedPath
          JsPath.setAt model.defaults, subcollectionEmbedPath, subcollection
  ###
  @method.
  @signature: Model::validate(callback)
  @param: callback
  @return: errs — that were encountered in the walk.
  @description: validate the data of "this", emitting events.
  ###
  validate:(callback) -> Validator.validate this, callback

  @validateAt = (path, value, sendMessage = no) ->
    [isValid, message] = do =>
      if @paths[path]?
        validators = @validators[path]
        for { validate, message } in validators
          try success = validate value
          catch e then return [no, message]
          return [!!success, unless success then message]
        return [yes]
      else return [no, 'unknown field']

    return isValid  unless sendMessage
    return { isValid, message }
  ###
  @constructor.
  @signature: Model::getClient()
  @returns: client - of the constructor.
  ###
  getClient: ->
    @constructor.getClient()

  getCache: ->
    @constructor.getCache()
  ###
  @constructor.
  @signature: Model::getClient()
  @returns: collection name - of the constructor.
  ###
  getCollectionName: ->
    @constructor.getCollectionName()

  save: require('./save').save

  ###
  @method.
  @signature: Model::saveAtomically(model, callback)
  @throws: an schemaError
  ###
  saveAtomically:(model, callback) ->
    if @notRoot
      throw new Error \
        "don't call .saveAtomically() on a non-root node."
    else
      @save callback
  #
  #getMemoByNameAndPath:(memoName, path) ->
  #  { constructor, data } = this
  #  path = path.slice()
  #  memo = constructor[memoName][path.join '.']
  #  return [] unless memo
  #  prop = path.pop()
  #  parent = JsPath.getAt data, path
  #  [memo, prop, parent]
  #
  #setSubcollection:(path, array) ->
  #  [annotation, prop, parent] = @getMemoByNameAndPath 'subcollections', path
  #  subcollection = new Subcollection this, array, annotation
  #  parent[prop] = subcollection
  ###
  @method.
  @signature: Model::set(data)
  @param: data - a map of paths to set data to.  Use dot notation if you
    want to reach into objects, as there is no way to recursively merge JS
    objects without astonishing side effects.  Object notation "clobbers"
    sibling properties.
  @description: sets properties to the model by path.
  ###
  set:(data) ->
    model = this
    { constructor } = model
    new Traverse(data)
      .forEach (node) ->
        return if not node?
        if node.constructor is ObjectId
          @update node, yes
        if Array.isArray node
          type = constructor.subcollections[@path.join '.']
          subcollection = new Subcollection model, node, type
          @update subcollection
        else
          if @path.length
            type = Model.getType model, @path
            if type and type isnt Object
              @update Model.castValue(node, type), yes
        return
#          if @node instanceof Model
#            @update @node, yes
    # traverse again to set the path
    # TODO: try to optimize this so we only need to walk once.
    new Traverse(data)
      .forEach (node) ->
        if node instanceof Model
          # I am not 100% convinced that this assumption will hold true:
          node.isRoot_ = no
          node.rootNode_ = model
          node.path_ = @path
          node.parent_ = @parent.node
          @update node
        return
          #@node
    for own path, value of data
      JsPath.setAt model.data, path, value
    # TODO: this is a bit ugly:
    model._id = data._id if data._id
  ###
  @function.
  @signature: attachOuterAccessor_(model, path)
  @param: model
  @param: path - the path (inside data) we want to alias.
  @description: helper to add accessors onto the root level
    of the model to access the members on the root level of
    the model's data object.
  ###
  attachOuterAccessor_ = (model, path) ->
    defineProperty model, path,
      enumerable: yes
      get : -> model.data[path]
      set :(value) -> model.data[path] = value

  shouldBeSaved:(path) ->
    if path is '_id' then no else console.log path; yes
  ###
  @method.
  @signature Model::get()
  @description: traverse the model (which implicitly will call
    any getters), prune nulls and undefineds, return the results
    of the traversal.
  ###
  get:(shouldPrune = no) ->
    model = this
    model.applyDefaults()
    data = extend {}, model.defaults, if shouldPrune then model.prune() else model.data
    # this will call the getters and return a new object
    new Traverse(data).forEach ->
      if @node instanceof Subcollection
        @update [].slice.call @node
      else
        @update @node?.get?() or @node

  getId: ->
    # TODO: implement plugins
    id = @data._id
    if 'string' is typeof id
      new ObjectId id
    else
      id

  equals:(model, deep = no) ->
    unless deep
      @getId()?.equals? id  if id = model?.getId?()
    # TODO: I'm not currently interested in "deep", but it might be needed later CT

  prune:do ->
    applyFilter = (node, constructor, pathName) ->
      filter = constructor.filters[pathName]
      filter node
    (isHard = no) ->
      model = this
      { constructor } = model
      method = if isHard then 'forEach' else 'map'
      prunedData = new Traverse(model.data)[method] (node) ->
        pathName = @path.join '.'
        if node instanceof ObjectId
          @update ObjectId(node + ''), yes
        else if pathName is '_id'
          # it's the mongo ObjectId
          @update node, yes
        else if pathName of constructor.embeds
          # it's a directly-embedded doc
          @update node.prune(), yes
        else if pathName of constructor.subcollectionEmbeds
          prunedCollection = (embed.prune(isHard) for embed in node)
          # it's a subcollection of embeds
          @update prunedCollection, yes
        else if pathName of constructor.paths # it's a schematical path
          if pathName of constructor.filters # it needs filtered
            @update applyFilter(node), yes
          else if pathName.length # it's schematical
            @update node, yes
          else
            @update node
        else
          # never heard of it; pruning!
          @remove()
      prunedData

  updateInstances:(atomically) ->
    prunedModifier = {}
    for own op of atomically
      prunedModifier[op] = {}
      for own field, val of atomically[op]
        unless field in ['snapshot', 'snapshotIds'] # TODO: this is a one-off hack.
          prunedModifier[op][field] = val

    if @constructor.getBroadcastable()
      @emit 'updateInstance', prunedModifier or this

  update:(atomically, callback = ->) ->
    model = this
    if 'function' is typeof atomically
      callback = atomically
      atomically = undefined
    unless atomically
      Model::save.call model, (err) ->
        if err
          callback err
        else
          model.updateInstances()
          callback null
    else
      collection = model.constructor.getCollection()
      update = { _id: model.getId() }
      for own operator, operation of atomically when operator is '$set'
        for own path, value of operation
          splittedPath = path.split '.'
          type = Model.getType model, splittedPath
          validators = model.constructor.validators[path]
          if validators?.length
            for { validate, name, message } in validators when not validate value
              return callback { message, name, value }
          if type and type isnt Object
            value = Model.castValue value, type
            operation[path] = value
      { operation } = new MongoOp(atomically)
        .map(model.applySetters.bind(model))
        .applyTo(model) # first update the one in memory.
      collection.update update, operation, (err) -> # then update the one in the database.
        if err
          callback err
        else
          model.updateInstances(atomically)
          callback null

  applySetters: (operator, operation) ->
    out = {}
    for own k, v of operation
      setter = @constructor.setters[k]
      if setter?
        v = setter.call this, v
      out[k] = v
    return out

  @_hardDelete = @remove

  remove:(callback) ->
    if @constructor.softDelete
      Trash = require '../trash'
      Trash.create this
    @constructor._hardDelete { _id: @getId() }, callback

  @remove:(selector, callback) ->
    if @softDelete
      Trash = require '../trash'
      @some selector, {}, (err, rows) =>
        Trash.create row for row in rows
        @_hardDelete selector, callback
    else
      @_hardDelete selector, callback

  ['getAt', 'setAt', 'deleteAt']
    .forEach (method) => this::[method] = (path) ->
      JsPath[method].call null, @data, path
###
Footnotes:
  1 - ad hoc properties not associated with a schema are fine, but we don't persist them to Mongo.
  2 - apply defaults / validations on output (not here).
  3 - the human-readable description of the schema, including "type annotations" (JS constructors/primitive casts, really) and validation functions (including some sugared inbuilt ones).
  4 - if it has a name, it may be a constructor; this might be botched.
  5 - because of overloading, we need to make sure this isn't a field called "validator".
  6 - defaults are applied on output.
  7 - normal validators only take 1 argument: a value which needs to be validated.  There are also a class of so-called "curried" validators that take 2 arguments (e.g. pattern and enum): the first is arbitrarily supplied during schema creation, and the second is the value described above which needs to be validated.
###
