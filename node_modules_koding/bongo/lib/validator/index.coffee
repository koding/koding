# coffeelint: disable=cyclomatic_complexity

module.exports = class Validator

  JsPath = require '../jspath'
  { ValidationError,
   ValidationErrors } = require '../errortypes'

  @inbuilts = require './inbuilts'

  @validate = (model, callback) ->
    errs = []
    { data, defaults } = model
    { constructor } = model
    for own path, validators of constructor.validators
      for { name, message, validate, option } in validators
        unless 'string' is typeof message
          { errorCode, message } = message
        value = JsPath.getAt(data, path) ? JsPath.getAt(defaults, path)
        err = null
        valid =
          try
            validate value
          catch e
            message = "#{message}\n#{e.message}"
            no
        if name is 'required' and valid and not value?
          errs.notRequired = yes
        unless valid
          path = (@path or []).concat path
          err = new ValidationError message, constructor, {
            path
            value
            option
            errorCode
          }
          errs.push err
          #model.emit 'error', err, model
    # recursively .validate() embedded models
    for own path of constructor.embeds
      embeddedModel = JsPath.getAt data, path
      if embeddedModel?
        errs.push embeddedModel.validate()...
    # recursively validate every
    for own path of constructor.subcollectionEmbeds
      subcollection = JsPath.getAt data, path
      if subcollection
        for embeddedModel, index in subcollection
          errs.push embeddedModel.validate()...
    if errs.length and not errs.notRequired
      err = new ValidationErrors errs
    else
      err = null
    callback? err, model
    errs


  constructor:(@name, validator, option) ->
    [@message, @validate] = validator
    # handle a special case where "required" is no, which means that we
    # should simply respond affirmatively regardless of the input
    if @name is 'required' and option is no then @validate = -> yes
    # handle a special case where the arity of the
    # validator is 2, when we curry in the RHS as
    # the first argument of the function.
    if @validate.length is 2
      if 'function' is typeof option
        @option = option
      else
        # if "option" is an array, assume that
        # the first item is a custom error message.
        [@message, @option] = option
      # curry the option into the validation validate:
      # TODO: validators should have an execution context.
      @validate = @validate.bind null, @option
