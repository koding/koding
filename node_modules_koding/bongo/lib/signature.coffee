class Signature

  { ObjectId } = require 'bongo'

  constructor: (@paramTypes) ->
    # instance = Signature.getInstance @paramTypes

    # return instance  if instance?

    @slug = @createSlug()

    rest = no

    for type, i in @paramTypes when type.isRest
      throw new Error 'Multiple rest parameters are not allowed.'  if rest

      @restParamType    = type
      @restParamIndex   = i
      @paramTypesBefore = @paramTypes[0...i]
      @paramTypesAfter  = @paramTypes[i + 1..@paramTypes.length]

      rest = yes

  spread: (rest...) -> @test rest

  test: (params) ->
    return no  unless @testLength params

    if    @restParamType?
    then  @testWithRest params
    else  @testEach params

  testEach: (params, types = @paramTypes) ->
    for param, i in params when not @testType param, types[i] ? types.tag
      return no
    return yes

  testWithRest: (params) ->
    i             = @restParamIndex
    after         = params.length - @paramTypesAfter.length

    paramsBefore  = params[0...i]
    restParam     = params[i...after]
    paramsAfter   = params[after...params.length]

    return no  unless @testEach paramsBefore, @paramTypesBefore
    return no  unless @testEach restParam,    @restParamType
    return no  unless @testEach paramsAfter,  @paramTypesAfter
    return yes # by process of elimination...

  testLength: (params) ->
    if @restParamType?
      # rest params can be zero or more in number:
      @paramTypesBefore.length + @paramTypesAfter.length <= params.length
    else
      # otherwise, the length must match exactly:
      @paramTypes.length is params.length

  testType: (param, type) -> switch
    when param is null
      # NOTE: any "type" can hold the null value.
      yes

    # NOTE: I don't care about boxed primitives (number, string, boolean)
    # (don't use them). In practice, these will only be called by our own RPC
    # system, which will never use boxed primitives.
    when type is Boolean
      return 'boolean' is typeof param

    when type is Number
      return 'number' is typeof param

    when type in [String, ObjectId]
      # ObjectIds come as strings from the client
      return 'string' is typeof param

    # NOTE: I don't care about old safari/chrome RegExp bug.  This is node.js.
    # Those bugs do not exist here.
    when type is Function
      return 'function' is typeof param

    # NOTE: this is, so far as I know, the most specific check we can do.
    when type is Object
      return (Object param) is param

    when Array.isArray type
      return no  unless Array.isArray param
      return no  for p in param when not @testType p, type[0]
      # by process of elimination, we know that no element doesn't match the tag:
      return yes

    else return no

  createSlug: -> @slug ?= Signature.createSlug @paramTypes

  # Object pool:
  @pool = Object.create null

  @poolPath = (paramTypes) ->
    paramTypes?.map? (paramType) ->
      { name, tag } = paramType
      return "[#{paramType[0].name}]"  if Array.isArray paramType
      return "R(#{tag.name})"          if paramType is Rest
      return name

  @poolKey = (paramTypes, delim = ',') -> (@poolPath paramTypes).join delim

  @getInstance = (paramTypes, andKey = no) ->
    key = @poolKey paramTypes
    instance = @pool[key]

    if    andKey
    then  [ instance, key ]
    else  instance

  @createSlug = (paramTypes) ->
    @poolPath paramTypes
    .map (paramType) -> paramType.replace /(\w+)/, (_, [word]) -> word
    .join ','

Rest = (tag) -> { tag, isRest: yes, __proto__: Rest }

signature = (paramTypes...) -> new Signature paramTypes

signature.Rest = Rest

module.exports = signature
