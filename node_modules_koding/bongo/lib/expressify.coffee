onceReady = (bongo, callback) ->
  return callback null  if bongo.dbClientReady
  bongo.once 'dbClientReady', callback

module.exports = ->
  { dash } = require 'bongo'

  bongo = this

  sendMetrics = (start, message) ->

    duration   = new Date() - start
    { method } = message
    bongo.metrics.sendMethodMetrics { method, duration }


  process = (req, client, callback) ->

    [client, callback] = [null, client]  unless callback

    { channelName, queue } = req.body

    responses = new Array queue.length

    workQueue = queue.map (message, i) -> ->

      start = new Date()
      bongo.handleRequest channelName, { message, client }, (secretName, callbackId, args) ->

        if bongo.metrics
          sendMetrics start, message

        bongo.scrubResponse callbackId, args, (message) ->
          responses[i] = message
          workQueue.fin()

    dash workQueue, -> callback responses

  (req, res, next) ->

    { sessionToken, userArea, queue } = req.body

    unless queue?.length
      return res.status(400).end()

    sendResponse = (payload) -> res.send payload

    if sessionToken and userArea
      onceReady bongo, ->
        bongo.fetchClient sessionToken, userArea, (client) ->
          unless client
            console.log "bongo.fetchClient: #{sessionToken} not found in #{userArea}"
            return res.status(500).send 'An error occcurred'

          process req, client, sendResponse
    else
      process req, sendResponse
