onceReady = (bongo, callback) ->
  return callback null  if bongo.dbClientReady
  bongo.once 'dbClientReady', callback

module.exports = (options = {}) ->
  { dash }    = require 'bongo'
  RateLimit   = require('ratelimit.js').RateLimit
  bongo       = this

  { rateLimitOptions } = options

  if rateLimitOptions?.enabled
    { userRules, guestRules } = rateLimitOptions
    rateLimiter = new RateLimit bongo.redisClient, userRules

  sendMetrics = (start, message) ->

    duration   = new Date() - start
    { method } = message
    bongo.metrics.sendMethodMetrics { method, duration }


  rateLimit = (id, weight, callback) ->

    return callback no  unless rateLimitOptions.enabled

    weight ?= 1
    # if id start with guest- use guest rules for the user
    rateLimiter.rules = if /^guest-/.test id
    then rateLimiter.convertRules guestRules
    else rateLimiter.convertRules userRules

    rateLimiter.incr id, weight, (err, isRateLimited) ->
      console.log "Rate limit error occurred: #{err}"  if err
      callback isRateLimited


  process = (req, client, callback) ->

    [client, callback] = [null, client]  unless callback

    { channelName, queue } = req.body

    responses = new Array queue.length

    workQueue = queue.map (message, i) -> ->

      start = new Date()
      bongo.handleRequest channelName, { message, client }, (secretName, callbackId, args) ->

        sendMetrics start, message  if bongo.metrics

        bongo.scrubResponse callbackId, args, (message) ->
          responses[i] = message
          workQueue.fin()

    dash workQueue, -> callback responses

  (req, res, next) ->

    { sessionToken, userArea, queue } = req.body

    unless queue?.length
      return res.status(400).end()

    sendResponse = (payload) -> res.send payload

    if sessionToken and userArea
      onceReady bongo, ->
        bongo.fetchClient sessionToken, userArea, (client) ->
          unless client
            console.log "bongo.fetchClient: #{sessionToken} not found in #{userArea}"
            return res.status(500).send 'An error occcurred'

          rateLimit client.username, queue.length, (isRateLimited) ->
            return res.status(429).send 'Rate limit exceeded'  if isRateLimited
            process req, client, sendResponse

    else
      # use sessionToken as id for rate limiting
      rateLimit sessionToken, queue.length, (isRateLimited) ->
        return res.status(429).send 'Rate limit exceeded'  if isRateLimited
        process req, sendResponse


