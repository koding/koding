onceReady = (bongo, callback) ->
  return callback null  if bongo.dbClientReady
  bongo.once 'dbClientReady', callback

module.exports = (options = {}) ->
  async       = require 'async'
  RateLimit   = require('ratelimit.js').RateLimit
  bongo       = this

  { rateLimitOptions } = options

  if rateLimitOptions?.enabled
    { userRules, guestRules } = rateLimitOptions
    rateLimiter = new RateLimit bongo.redisClient, userRules

  sendMetrics = (start, message) ->

    duration   = new Date() - start
    { method } = message
    bongo.metrics.sendMethodMetrics { method, duration }


  rateLimit = (id, weight, callback) ->

    return callback no  unless rateLimitOptions.enabled

    weight ?= 1
    # if id start with guest- use guest rules for the user
    rateLimiter.rules = if /^guest-/.test id
    then rateLimiter.convertRules guestRules
    else rateLimiter.convertRules userRules

    rateLimiter.incr id, weight, (err, isRateLimited) ->
      console.log "Rate limit error occurred: #{err}"  if err
      callback isRateLimited

  queueCount = 0
  OBSERVE_QUEUE = {}

  observeQueue = (id, calls, responses, callback) ->

    OBSERVE_QUEUE[id] = yes

    setTimeout ->
      return  unless OBSERVE_QUEUE[id]
      console.log '[Expressify:UNHANDLED_QUEUE]', calls
      OBSERVE_QUEUE[id] = null
      callback responses
    , 7000


  process = (req, client, callback) ->

    [client, callback] = [null, client]  unless callback

    { channelName, queue } = req.body

    queueId = queueCount++
    # reset on every ~2k calls
    queueCount = 0  if queueCount > 2048

    responses = new Array queue.length

    calls = queue.map (message, i) ->
      { method: "#{message.method.method ? message.method}", called: no }

    workQueue = queue.map (message, i) -> (fin) ->

      start = new Date()

      # Generate timed out response which will be replaced with
      # the real response if it works in the given time.
      responses[i] = {
        arguments : [{ message: 'Timed out' }]
        callbacks : {}
        method    : +(Object.keys message.callbacks)[0]
      }

      bongo.handleRequest channelName, { message, client }, (secretName, callbackId, args) ->

        sendMetrics start, message  if bongo.metrics
        responses[i].method = callbackId

        bongo.scrubResponse callbackId, args, (message) ->
          responses[i] = message
          calls[i].called = yes
          fin()

    observeQueue queueId, calls, responses, callback

    async.parallel workQueue, ->
      callback responses  if OBSERVE_QUEUE[queueId]
      OBSERVE_QUEUE[queueId] = null


  (req, res, next) ->

    { sessionToken, userArea, queue } = req.body

    unless queue?.length
      return res.status(400).end()

    sendResponse = (payload) ->
      res.send payload

    if sessionToken and userArea

      onceReady bongo, ->

        bongo.fetchClient sessionToken, userArea, (client) ->

          unless client
            console.log "bongo.fetchClient: #{sessionToken} not found in #{userArea}"
            return res.status(500).send 'An error occcurred'

          payload = []

          queue.forEach (_req) ->
            if _req.method is 'authenticateUser'
              method  = +(Object.keys _req.callbacks)[0]
              account = client.connection.delegate
              payload.push { arguments: [ account ], callbacks: {}, method }

          if queue.length is payload.length
            sendResponse payload
            return

          rateLimit client.username, queue.length, (isRateLimited) ->
            return res.status(429).send 'Rate limit exceeded'  if isRateLimited
            process req, client, sendResponse

    else
      # use sessionToken as id for rate limiting
      rateLimit sessionToken, queue.length, (isRateLimited) ->
        return res.status(429).send 'Rate limit exceeded'  if isRateLimited
        process req, sendResponse


