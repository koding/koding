###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@class: bongo
@description: the main klass of the library.
@author: Christopher Thorn <chris@koding.com>
###

{EventEmitter} = require 'events'

module.exports = class Bongo extends EventEmitter
  [READY, NOTREADY] = [0,1]
  # core
  url = require 'url'
  fs = require 'fs'
  nodePath = require 'path'

  require 'colors'

  @mongo          = require 'mongodb'
  {extend}        = require 'underscore'
  @JsPath = JsPath = require 'jspath'
  @Inflector      = require 'inflector'
  # lib
  # the base klass of the library:
  @Base = Base    = require './base'
  # the model klass of the library:
  @Model = Model  = require './model'
  ModelRegistry   = require './modelregistry'
  @ModelCursor    = require './modelcursor'
  # the rest of the basics:
  @Subcollection  = require './subcollection'
  @ObjectId       = require './objectid'
  @ObjectRef      = require './objectref'
  @Validator      = require './validator'
  @Register       = require './register'
  @util           = require './util'

  {daisy, @daisy, @dash, @sequence, @race} = require 'sinkrow'

  {@future} = require 'sinkrow-future'

  {Scrubber, Store} = require 'koding-dnode-protocol'

  Traverse = require 'traverse'

  EXCHANGE_OPTIONS =
    autoDelete  : yes
    durable     : no
    type        :'topic'

  @signature = require './signature'

  @secure =(fn)->
    fn.isSecurityEnabled = yes
    fn

  {@asynchronizeOwnMethods} = require './util'

  {BongoError}    = require './errortypes'

  Client = require './client'

  @throwIt = (it) ->
    console.error it  if it?
    # process.kill process.pid, 'SIGTERM'

  constructor:(options)->
    {@mq, @mongo, @resourceName, @root, @fetchClient, @verbose, models, @precompiledApi} = options
    @setClient @mongo
    @localStore = new Store
    @remoteStore = new Store
    @clients = {}
    @models = {}
    @stack = []
    @services = {}
    #@initBlacklist options.blacklist
    @loadModels models
    @on 'error', Bongo.throwIt
    @mq?.ready => @mq.connection?.on 'error', (err) ->
      Bongo.throwIt err
      process.exit 0
    @setMaxListeners 0
    @emit 'newInstance', this

  bound: require 'koding-bound'

  defineModel:(name, model)->
    @models[name] = model
    return  unless model.addBongo? this
    @emit 'newModel', name, model
    model.on 'needsPopulated', (def, path)=>
      path = if Array.isArray path then path else path.split '.'
      names = JsPath.getAt def, path
      unless Array.isArray names
        names = [names]
        JsPath.setAt def, path, names
      names.forEach (name, i)=>
        if target = @models[name]
          JsPath.setAt def, path.concat(i), target
      @on 'newModel', (newName, newModel)->
        if newName in names
          JsPath.setAt def, path.concat(names.indexOf newName), newModel

  listModels=(root="", modelPath, acc={})->
    path = nodePath.join root, modelPath
    stat = fs.statSync path
    if stat.isDirectory()
      names = fs.readdirSync path
      for name in names
        listModels root, nodePath.join(modelPath, name), acc
    else if /(\.coffee|\.js)$/.test path
      acc[path] = NOTREADY
    return acc

  createModelRegistry:(modelPath)->
    acc = {}
    if Array.isArray modelPath
      listModels @root, item, acc  for item in modelPath
    else
      listModels @root, modelPath, acc
    new ModelRegistry acc

  loadModels: (modelPath) ->
    @registry = @createModelRegistry(modelPath)
    @registry.forEach (path) =>
      try model = require path
      catch e
        console.error e
        err = new Error
        err.originalError = e
        err.message = "Error loading a class: #{path}"
        return @emit 'error', err
      if model.name? and ('function' is typeof model)
        @defineModel model.name, model
      else
        @defineModel name, konstructor  for own name, konstructor of model
      @registry.setState path, READY
    @emit 'ready'

  getInstanceRoutingKey =(inst, event)->
    "oid.#{inst.getId()}.event.#{event}"

  getStaticRoutingKey =(konstructor, event)->
    "constructor.#{konstructor.name}.event.#{event}"

  handleEvent:(type, ctx, event, rest)->
    switch type
      when 'instance'
        if event is 'notification'
          @publishEventToExchange event, rest[0]
        if event is 'control'
          @publishToControlExchange event, rest[0]
        else
          payload     = JSON.stringify rest[0] or null
          routingKey  = getInstanceRoutingKey ctx, event
          @mq.emit 'updateInstances', routingKey, payload, autoDelete: no
      when 'static'
        if event is 'broadcast'
          [secretChannelId, message] = rest
          @fetchBrokerExchange (brokerExchange)->
            messageStr = JSON.stringify message
            brokerExchange.publish secretChannelId, messageStr  if messageStr?
        else
          broadcastable = ctx.getBroadcastable()
          if !broadcastable? or broadcastable # TODO: this is insecure by default :(
            [data] = rest
            data = JSON.stringify data
            @mq.emit 'updateInstances', getStaticRoutingKey(ctx, event), data, autoDelete: no

  publishToControlExchange:(exchangeEvent, data)->
    options =
      autoDelete  : yes
      durable     : no
      type        :'fanout'
    @publishEventToExchange exchangeEvent, data, options

  publishEventToExchange: (exchangeEvent, data, options)->
    options or= EXCHANGE_OPTIONS
    # generally data has {routingKey, event, contents}
    {routingKey} = data
    delete data.routingKey
    @mq.connection.exchange exchangeEvent, options, (exchange)->
      exchange.publish routingKey, data
      exchange.close() # Don't leak a channel!

  parseRoutingKey: do ->
    getEdgeMeaning = (i)->
      switch i
        when 0 then 'origin'
        when 1 then 'secretChannelId'
        when 2 then 'username'
        when 3 then 'service'
        when 4 then 'event'
        else        "additionalProperty#{i-4}"

    parseRoutingKey = (routingKey)->
      routingKey.split('.').reduce (acc, edge, i)->
        acc[getEdgeMeaning i] = edge
        acc
      , {}

  respondToClient:(routingKey, message)->
    message =\
      if Buffer.isBuffer(message) or 'string' is typeof message
        message
      else
        JSON.stringify message
    @fetchBrokerExchange (brokerExchange)->
      brokerExchange.publish routingKey, message

  getBrokerExchangeOptions:->
    type        : 'topic'
    autoDelete  : no
    durable     : no

  fetchBrokerExchange:(callback)->
    if @brokerExchange is null
      @once 'brokerExchangeReady', => @fetchBrokerExchange callback
    else unless @brokerExchange?
      @brokerExchange = null
      @mq.connection.exchange 'broker', @getBrokerExchangeOptions(),
        (@brokerExchange)=>
          @emit 'brokerExchangeReady'
          callback brokerExchange
    else callback @brokerExchange

  authenticateUser:(clientId, callback)->
    @fetchClient clientId, (client)=>
      @emit 'authenticateUser', client, callback

  createPresenceMemberKey:->
    serviceGenericName  = @resourceName
    serviceUniqueName   = @resourceName #@getRabbitMqResourceName()
    "serviceType.bongo.serviceGenericName.#{serviceGenericName}.serviceUniqueName.#{serviceUniqueName}"

  createPresence:->
    Presence = require 'koding-rabbit-presence'
    new Presence {
      connection  : @mq.connection
      member      : @createPresenceMemberKey()
      exchange    : 'services-presence'
    }

  establishPresence:->
    return  if @presence?
    @presence = @createPresence()
    @presence.announce()
    @presence.listen()
    @presence.on 'join',  (serviceKey)=> @services[serviceKey] = 1
    @presence.on 'leave', (serviceKey)=> delete @services[serviceKey]

  monitorPresence:(callbacks)->
    return  unless @presence?
    callbacks.join serviceKey  for serviceKey in Object.keys @services
    @presence.on 'join',  callbacks.join  if callbacks.join?
    @presence.on 'leave', callbacks.leave if callbacks.leave?

  connect:(callback=->)->
    @once 'connected', =>
      if @dbClientReady then callback()
      else @once 'dbClientReady', callback
    @mq.ready =>
      @establishPresence()
      exchangeOptions = {type:'fanout', autoDelete: yes}
      @mq.connection.exchange @resourceName, exchangeOptions, (@exchange)=>
        @mq.connection.queue  @resourceName, (@queue)=>
          @emit 'connected'
          queue.bind exchange, ''
          queue.on 'queueBindOk', =>
            queue.subscribe( (message, headers, deliveryInfo)=>
              {routingKey} = deliveryInfo
              if routingKey is 'auth.join'
                if @precompiledApi
                  @respondToClient message.routingKey,
                    method    : 'handshakeDone'
                    arguments : []
                    callbacks : {}
                else
                  @describeApi (api)=>
                    response =
                      method    : 'defineApi'
                      arguments : [api]
                      callbacks : {}
                    @respondToClient message.routingKey, response
              else if routingKey is 'auth.leave' then # ignore
              else
                @handleRequest routingKey,
                  if message.data? then "#{message.data}"
                  else message
            ).addCallback (ok)=> @consumerTag = ok.consumerTag

  disconnect:(callback)->
    {queue} = this
    return callback new BongoError 'You are not connected!'  unless queue?
    queue.unsubscribe(@consumerTag).addCallback -> queue.close()
    delete @consumerTag
    delete @readyState = 0
    delete @queue
    callback? null

  revive:(data)->
    {models} = this
    new Traverse(data).forEach (node)->
      if data?.bongo_?
        konstructor = models[data.bongo_.constructorName]
        model =\
          try new konstructor data
          catch e then data
        @update model, yes
      else
        @update node

  handleRequest:(secretName, message, callback)->
    unless @dbClientReady
      @once 'dbClientReady', => @handleRequest secretName, message
      return
    console.log message.green  if @verbose
    message =
      try JSON.parse message
      catch e then message
    {method, sessionToken, userArea} = message
    scrubber = new Scrubber @localStore
    unscrubbed = scrubber.unscrub message, (callbackId)=>
      storeKey = "#{secretName}#{callbackId}"
      unless @remoteStore.has storeKey
        @remoteStore.add storeKey, 
          if callback?
          then (args...) -> callback secretName, callbackId, args
          else (args...) => @handleResponse secretName, callbackId, args
      @remoteStore.get storeKey
    @invokeMethod method, unscrubbed, secretName, sessionToken, userArea

  pong:(callback)-> callback? Date.now()

  invokeMethod:do->
    ###
    @helper apply()
    @private
    @description - apply the method, conditionally currying the "client" object
    ###
    apply = (bongo, ctx, method, args, sessionToken, userArea) ->
      unless ctx?
        bongo.handleError "bad instance! #{method}"
        return
      if 'function' is typeof method
        fn = method
      else if ctx? and 'string' is typeof method
        # prefer the method with the trailing dollar, since this should be, by
        # convention, the version of the method which implements security for
        # a given model, and provides a wrapper for it; otherwise, search for
        # the method with the exact name.
        fn = ctx["#{method}$"] ? ctx[method]
      unless fn?
        bongo.handleError "unknown method! #{method}"
        return
      if fn.isSecurityEnabled
        bongo.fetchClient sessionToken, userArea, (client) ->
          args = [client].concat args
          fn.apply ctx, args
      else
        fn.apply ctx, args
    ###
    @implementation
    ###
    (method, args, secretName, sessionToken, userArea)->
      unless method?
        @handleError 'No such method'
      else if method is 'ping' then @pong args[0]
      else if method is 'monitorPresence' then @monitorPresence args[0]
      else if method is 'authenticateUser' then @authenticateUser args... # TODO: this doesn't need to be specialcase. C.T.
      else if method?.method
        konstructor = Base.constructors[method.constructorName]
        unless konstructor?
          @handleError "No such constructor! #{method.constructorName}"
          return

        # TODO: for now, we're just warning about unrecognized signatures.
        #  in the future, we'll bail out here.
        validCall = konstructor.testSignature method.type, method.method, args
        unless validCall
          console.warn "unrecognized signature:", method, args

        switch method.type
          when 'static'
            if konstructor.hasSharedMethod method.method
              apply @, konstructor, method.method, args, sessionToken, userArea
            else
              @handleError "No such method! #{JSON.stringify method} #{args} #{secretName}"
          when 'instance'
            if konstructor::hasSharedMethod method.method
              if method.id
                konstructor.one? _id: method.id, (err, instance)=>
                  if err
                    @handleError err
                  else unless instance
                    @handleError "#{konstructor.name} instance with id #{method.id} is not found"
                  else
                    apply @, instance, method.method, args, sessionToken, userArea
              else if method.data
                instance = new konstructor method.data
                apply @, instance, method.method, args, sessionToken, userArea
            else
              @handleError "No such method! #{JSON.stringify method} #{args} #{secretName}"
          else
            @handleError 'Unknown method type!'
      else
        kallback = @localStore.get method
        if kallback?
          apply @, null, kallback, args, sessionToken, userArea
        else
          @handleError 'Unknown method type!'

  handleError:(message)->
    @emit 'error',
      if message?.message then {message: message.message}
      else {message}

  detectErrFirst:(cursor)->
    if cursor.path.length is 1 and
       cursor.path[0] is '0' and
       'string' is typeof cursor.node?.message

      # node_ instead of node since traverse strips out Error
      @emit 'errFirstDetected', cursor.node_

  scrubResponse: (callbackId, args, callback) ->
    scrubber = new Scrubber @localStore, @bound 'detectErrFirst'
    scrubber.scrub args, =>
      message = scrubber.toDnodeProtocol()
      message.method = callbackId
      callback message

  handleResponse: (secretName, callbackId, args) ->
    @scrubResponse callbackId, args, (message) =>
      @fetchBrokerExchange (brokerExchange) =>
        # when internal error send a generic error message to client
        if message?.arguments[0]?.internal?
          message.arguments[0] = {message:"Something went wrong!"}

        brokerExchange.publish secretName, JSON.stringify(message, @replacer)

  getMethodDescription:(name, konstructor)-> konstructor.getSharedMethods()

  describeApi:(callback)->
    api = {}
    # share the global constructors
    for own name, konstructor of Base.globalSharedConstructors
      api[name] = @getMethodDescription name, konstructor
    # share the constructors which are specific to this bongo instance
    for own name, konstructor of @models when konstructor.isShared
      api[name] = @getMethodDescription name, konstructor

    @callMiddleware api, -> callback api

  callMiddleware:(api, callback)->
    if @stack.length
      queue = @stack.map (fn)=>=>
        switch fn.length
          when 2 then fn.call this, api, -> queue.next()   # async style
          when 1 then fn.call this, api; queue.next()      # sync style
          else        callback new Error "Arity error! (got #{fn.length}; expected 1 or 2)"
      daisy queue, callback
    else
      callback api

  dispatchMethod:(contructorName, method, context, args)->
    # implement dispatch method

  getClient:-> Model.getClient()

  setClient:(rest...)->
    Model.setClient rest...
    Model.on 'dbClientReady', =>
      @dbClientReady = yes
      @emit 'dbClientReady'

  use:(fn...)-> @stack.push fn...

  expressify: require './expressify'
