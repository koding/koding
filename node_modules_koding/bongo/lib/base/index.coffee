###
Bongo.js
Unfancy models for MongoDB

@class: Base
@author: Christopher Thorn
###
{ EventEmitter2 } = require 'eventemitter2'
nodePath = require 'path'

module.exports = class Base extends EventEmitter2
  # native
  { defineProperty } = Object
  # contrib
  createId = require('hat').rack()
  Inflector = require 'inflector'
  ###
  Static events
  @description: see ./staticemitterdelegate.coffee
  ###
  {
    @on, @off, @addListener, @removeListener, @removeAllListeners, @once
    @listeners, @setMaxListeners, @emit, @getEmitter
  } = require './staticemitterdelegate'

  # oldEmit = @emit
  # @emit = (rest...) ->
  #   if @::mq?
  #     [event, data] = rest
  #     broadcastable = @getBroadcastable()
  #     if broadcastable
  #       if Array.isArray event
  #         event = event.join '.'
  #       @::mq?.trigger @name, event, data
  #   else
  #     oldEmit.apply this, rest

  ###
  @method: property of the constructor
  @signature: Base.mixin(stuff)
  @description: copy all the static and prototype members.
  ###
  mixin: @mixin = (source) ->
    for own key, val of source when key isnt 'constructor'
      if key is 'onTraitAdded'
        val.call this
        continue
      @[key] = val

  @trait = (root, trait) ->
    if 'function' is typeof root
      @mixin root
      @::mixin root.prototype if root.prototype?
    else
      [trait, root] = [root, trait] unless trait
      root ?= ''
      err = null
      traitPath = nodePath.join(root, trait)
      traitModule = \
        try require traitPath
        catch e then err = e
      if 'function' is typeof traitModule
        @trait traitModule
      else
        throw new Error "Couldn't load the trait #{traitPath} #{err}"

  @addGlobalListener = (event, listener) ->
    @emit 'global-listener-added', event, listener

  getInterfaceName: @getInterfaceName = (verb, noun, isPlural) ->
    noun = Inflector.pluralize noun if isPlural
    name = Inflector.camelize "#{verb}_#{noun}", yes, yes

  invoke: @invoke = (verb, noun, rest...) ->
    (@[@getInterfaceName(verb, noun)]?(rest...) and true) or false
  ###
  @method.
  @signatature: initializeSharedInstance()
  ###
  initializeSharedInstance:(options) ->
    model = this
    if model.constructor.isShared
      if options.bongo_?
        { instanceId } = options.bongo_
        model.bongo_ = options.bongo_
      else
        instanceId = createId()
        model.bongo_ = {
          constructorName : model.constructor.name
          instanceId
        }

  @wildcard = yes
  @maxListeners = 0

  warnAboutEventWhitelist = (konstructor, context, event) ->
    console.warn """
      No event whitelist in place for #{konstructor.name}!
      Emitting unguarded #{context} event: #{event}
      This needs to be fixed; we will stop supporting non-whitelisted events
      at some point in the near future.
      """

  constructor:(options = {}) ->

    @initializeSharedInstance options

    defineProperty this, '_events', { value: {} }, { writeable: yes }
    defineProperty this, 'wildcard', { value: yes }, { writeable: yes }
    defineProperty this, 'maxListeners', { value: 0 }, { writeable: yes }
    defineProperty this, 'listenerTree', { value: {} }, { writeable: yes }

    super()

    @on '*', (rest...) =>
      @constructor.bongos?.forEach (bongo) =>
        if not @constructor.instanceEvents_?
          warnAboutEventWhitelist @constructor, 'instance', @event
          bongo.handleEvent 'instance', this, @event, rest
        else if @event in @constructor.instanceEvents_
          # TODO: this is insecure by default :(
          { filter } = @constructor.sharedEvents?.instance[@event] or {}
          rest[0] =
            if 'function' is typeof filter then filter.call this, rest[0]
            else rest[0]
          bongo.handleEvent 'instance', this, @event, rest

  addGlobalListener: (event, listener) ->
    @emit 'global-listener-added', event, listener

  ###
  @property.
  @signature: Base.constructors
  @description - an array of all constructors (that have schema).
  ###
  defineProperty(this, 'constructors', { value: Object.create null })
  ###
  @property.
  @signature: Base.sharedConstructors
  @description - an array of shared constructors.
  ###
  defineProperty(this, 'sharedConstructors', { value: Object.create null })
  defineProperty(this, 'globalSharedConstructors', { value: Object.create null })
  ###
  @method: property of the constructor.
  @signature: Base.extend(constructor, proto)
  @param: statik - members to be mixed into the constructor.
  @param: proto - an optional object (or a function that returns
    an object) that provides the prototype properties for the
    model.  You can use this for even more sugar to assign
    instance methods to your models. It should contain a "constructor"
    property:
      @property - constructor - a named function that will be used as
        the constructor for the new klass.  If you don't name your
        function some features may break.  There is no way to change
        the name of a function runtime, since the Function::name
        property is read-only.  So, do give it name. :)
  @description: This is a sugar method intended to simplify
    inheritance for those who are using Bongo with JS.  Writing
    your application in CoffeeScript is recommended, but in that
    case you shouldn't use Model.extend—use classes instead.
  ###
  @extend = (statik, proto) ->
    props = [statik, proto]
    for prop, index in props
      if 'function' is typeof prop
        props[index] = new prop
    [proto, statik] = props unless proto
    parent = this
    child = proto.constructor
    for own prop of parent
      child[prop] = parent[prop]
    ctor = ->
      @constructor = child
      return
    ctor:: = parent::
    child:: = new ctor
    for own prop of proto
      child::[prop] = proto[prop]
    child.__super__ = parent::
    child.set statik
    child

  @addBongo = (bongo) ->
    defineProperty(this, 'bongos', { value: [] }) unless @bongos?
    @bongos.push bongo
    @on '*', (rest...) =>
      @bongos.forEach (bongo) =>
        { event } = @getEmitter()
        return  if event is 'needsPopulated'
        if not @staticEvents_?
          bongo.handleEvent 'static', this, event, rest
          warnAboutEventWhitelist this, 'static', event
        else if event in @staticEvents_
          # TODO: this is insecure by default :(
          { filter } = @sharedEvents?.static[event] or {}
          rest[0] = filter.call this, rest[0]  if 'function' is typeof filter
          bongo.handleEvent 'static', this, event, rest

  ###
  @method: property of the constructor.
  @stub.
  @description: this provides a a getter for the constructor
    which can then be overridden by a subklass, which will in
    any case return a constructor—but maybe not this exact one.
  ###
  @getExactConstructor = (data) -> this

  ###
  @method.
  @signature: Base::Uber(arguments...)
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid Uber() when you are using CoffeeScript—
    prefer super().
  ###
  Uber: ->
    @constructor.__super__.constructor.apply this, arguments

  ###
  @method: property of the constructor.
  @signature: Base.uber(methodName, arguments...)
  @description: Call a method on the superclass.
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid uber() when you are using CoffeeScript—
    prefer super().
  ###
  @uber = (methodName, args...) ->
    @__super__.constructor[methodName].apply this, args
  ###
  @method.
  @signature: Base::uber(methodName, arguments...)
  @description: Call a method on the superclass.
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid uber() when you are using CoffeeScript—
    prefer super().
  ###
  uber:(methodName, args...) ->
    @constructor.__super__[methodName].apply this, args

  @registerConstructor = ->
    Base.constructors[@name] = this  unless Base.constructors[@name]?
  ###
  @method: property of the constructor
  @signature: Model.set(options)
  @param: component - e.g.:
    - "client" will be passed into setClient()
    - "schema" will be passed into setSchema()
    - "validators" will be passed into setValidators()
  @description: overrides Base.set() and passes items
    to their appropriate setter method.  Ignores items
    that do not have setters.
  ###
  @set = (options) ->
    @registerConstructor()
    for own optionName, option of options
      methodName =
        new Inflector("set_#{Inflector.underscore optionName}")
          .decapitalize()
          .camelize(yes)
          .value
      if 'function' is typeof @[methodName]
        @[methodName] option
      else
        @[optionName] = option
    this

  getGroupedUnique = (groups) ->
    groupedUnique = {}
    for own group, grouped of groups
      unique = {}
      for single in grouped
        name = if 'string' is typeof single then single else single.name
        unique[name] = single
      groupedUnique[group] = unique
    return groupedUnique
  ###
  @method.
  @signature: Model.setSharedMethods(methods)
  @param: methods - an object containing the following
    properties:
    @property: static - an array of method names to share
      with the client that should be attached to the
      constructor.
    @property: instance - an array of method names to share
      with the client that should be attached to the
      prototype.
    @description: methods may be negated if they were
      shared by parent constructors by prefixing the method
      name with one or more "!"s (so don't do double
      negation, because it doesn't seem to make any sense
      in this context.)
  ###
  @setSharedMethods = (methods = {}) ->
    { static: @staticMethods_, instance: @instanceMethods_ } = methods

  @describeMethods = (methods = {}) ->
    (for own method, signature of methods
      [
        method
        if Array.isArray signature
        then signature.map (s) -> s.slug
        else [ signature.slug ]
      ]
    ).reduce (memo, [ method, descriptor ]) ->
      memo[method] = descriptor  if descriptor[0]?.length
      memo
    , {}

  @getSharedMethods = ->
    s = @describeMethods @staticMethods_
    i = @describeMethods @instanceMethods_
    a = @getClassAttributes()
    {
      statik      : s
      instance    : i
      attributes  : a
    }

  @getClassAttributes = -> @classAttributes_ ?= {}

  @setClassAttributes = (@classAttributes_) ->

  @hasSharedMethod = (method) ->
    method of @getSharedMethods()['statik']

  hasSharedMethod:(method) ->
    { instance } = @constructor.getSharedMethods()
    method of instance

  @getSignature = (context, method) -> switch context
    when 'static'     then @staticMethods_[method]
    when 'instance'   then @instanceMethods_[method]

  @testSignature = (context, method, args) ->
    unless signatures = @getSignature context, method
      return [no, []]

    signatures = [signatures]  unless Array.isArray signatures
    for signature in signatures
      # if signature isnt there, fail the test
      unless signature
        console.log "client requested a non existent function -> context:#{context} method:#{method}"
        return [no, signatures]
      return [yes, signatures]  if signature.test args
    return [no, signatures.map (signature) -> signature.slug]

  @setSharedEvents = (events) ->
    { keys } = Object
    groupedEvents = getGroupedUnique events
    sharedEvents = {}
    for own group, eventsByGroup of groupedEvents
      defineProperty this, "#{group}Events_", { value: keys eventsByGroup }
      sharedEvents[group] = (keys eventsByGroup).reduce (acc, key) ->
        val = eventsByGroup[key]
        val = { name: val }  if 'string' is typeof val
        acc[key] = val
        return acc
      , {}
    defineProperty this, 'sharedEvents', { value: sharedEvents, enumerable: yes }

  @share = (global) ->
    konstructor = this
    { name } = konstructor
    unless name
      throw new Error "Can't share an unnamed constructor"
    defineProperty konstructor, 'isShared', { value: yes }
    # TODO: outsource this for scalability reasons.
    # defineProperty constructor, 'sharedInstances', value: {}
    Base.sharedConstructors[name] = konstructor
    this

  @inheritanceChain = (Klass = this, glue) ->
    unless chain = @inheritanceChain_
      proto = Klass.prototype
      chain = [Klass]
      while proto = proto.__proto__
        chain.push proto.constructor
      # memoize the inheritance chain because it ought not to change
      # and it's a bit expensive to have to travese the inheritance
      # chain every time.
      defineProperty this, 'inheritanceChain_', { value: chain }
    if glue
      (constructor.name for constructor in chain).join glue
    else
      chain

  inheritanceChain:(glue) ->
    Base.inheritanceChain @constructor, glue

  # emit:(event, data) ->
  #   super
  #   id = @getId?() or @bongo_.instanceId
  #   if id? and event isnt 'newListener'
  #     if Array.isArray event
  #       event = event.join('.')
  #     wrappedData = {}
  #     wrappedData[event] = data
  #     @mq?.trigger "updateInstance", "object-#{id}", wrappedData

  @setBroadcastable = (@broadcastable_ = yes) ->

  @getBroadcastable = ->
    if @broadcastable_? then @broadcastable_ else yes

  toObjectRef: ->
    ref = new ObjectRef this
