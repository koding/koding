###
Bongo.js
Unfancy models for MongoDB

@class: Base
@author: Christopher Thorn
###
{EventEmitter2} = require 'koding-eventemitter2'
nodePath = require 'path'

module.exports = class Base extends EventEmitter2
  # native
  {defineProperty} = Object
  # contrib
  createId = require('hat').rack()
  Inflector = require 'inflector'
  ###
  Static events
  @description: see ./staticemitterdelegate.coffee
  ###
  {@on, @off, @addListener, @removeListener, @removeAllListeners, @once
   @listeners, @setMaxListeners, @emit, @getEmitter} = require './staticemitterdelegate'

  # oldEmit = @emit
  # @emit =(rest...)->
  #   if @::mq?
  #     [event, data] = rest
  #     broadcastable = @getBroadcastable()
  #     if broadcastable
  #       if Array.isArray event
  #         event = event.join '.'
  #       @::mq?.trigger @name, event, data
  #   else
  #     oldEmit.apply @, rest

  ###
  @method: property of the constructor
  @signature: Base.mixin(stuff)
  @description: copy all the static and prototype members.
  ###
  mixin: @mixin = (source)->
    @[key] = val for own key,val of source when key isnt 'constructor'
  
  @trait =(root, trait)->
    if 'function' is typeof root
      @mixin root
      @::mixin(root::) if root::?
    else
      [trait, root] = [root, trait] unless trait
      root ?= ''
      err = null
      traitPath = nodePath.join(root, trait)
      traitModule =\
        try require traitPath
        catch e then err = e
      if 'function' is typeof traitModule
        @trait traitModule
      else
        throw new Error "Couldn't load the trait #{traitPath} #{err}"

  @addGlobalListener = (event, listener) ->
    @emit "global-listener-added", event, listener

  getInterfaceName: @getInterfaceName = (verb, noun, isPlural)->
    noun = Inflector.pluralize noun if isPlural
    name = Inflector.camelize "#{verb}_#{noun}", yes, yes
  
  invoke: @invoke = (verb, noun, rest...)->
    (@[@getInterfaceName(verb, noun)]?(rest...) and true) or false
  ###
  @method.
  @signatature: initializeSharedInstance()
  ###
  initializeSharedInstance:(options)->
    model = @
    if model.constructor.isShared
      if options.bongo_?
        {instanceId} = options.bongo_
        model.bongo_ = options.bongo_
      else
        instanceId = createId()
        model.bongo_ = {
          constructorName : model.constructor.name          
          instanceId
        }
      
  @wildcard = yes
  @maxListeners = 0
  
  constructor:(options={})->
    @initializeSharedInstance options
    defineProperty @, '_events', value: {}, writeable: yes
    defineProperty @, 'wildcard', value: yes, writeable: yes
    defineProperty @, 'maxListeners', value: 0, writeable: yes
    defineProperty @, 'listenerTree', value: {}, writeable: yes
    super options
    @on '*', (rest...)=>
      @constructor.bongos.forEach (bongo)=>
        bongo.handleEvent 'instance', @, @event, rest

  addGlobalListener: (event, listener) ->
    @emit "global-listener-added", event, listener
    
  ###
  @property.
  @signature: Base.constructors
  @description - an array of all constructors (that have schema).
  ###
  defineProperty(@, 'constructors', value: {})
  ###
  @property.
  @signature: Base.sharedConstructors
  @description - an array of shared constructors.
  ###
  defineProperty(@, 'sharedConstructors', value: {})
  defineProperty(@, 'globalSharedConstructors', value: {})
  ###
  @method: property of the constructor.
  @signature: Base.extend(constructor, proto)
  @param: statik - members to be mixed into the constructor.
  @param: proto - an optional object (or a function that returns
    an object) that provides the prototype properties for the
    model.  You can use this for even more sugar to assign
    instance methods to your models. It should contain a "constructor"
    property:
      @property - constructor - a named function that will be used as 
        the constructor for the new klass.  If you don't name your
        function some features may break.  There is no way to change 
        the name of a function runtime, since the Function::name 
        property is read-only.  So, do give it name. :)
  @description: This is a sugar method intended to simplify
    inheritance for those who are using Bongo with JS.  Writing
    your application in CoffeeScript is recommended, but in that
    case you shouldn't use Model.extend—use classes instead.
  ###
  @extend = (statik, proto)->
    props = [statik, proto]
    for prop, index in props
      if 'function' is typeof prop
        props[index] = new prop
    [proto, statik] = props unless proto
    parent = @
    child = proto.constructor
    for own prop of parent
      child[prop] = parent[prop]
    ctor =->
      @constructor = child
      return
    ctor:: = parent::
    child:: = new ctor
    for own prop of proto
      child::[prop] = proto[prop]
    child.__super__ = parent::
    child.set statik
    child

  @addBongo =(bongo)->
    defineProperty(@, 'bongos', value: []) unless @bongos?
    @bongos.push bongo
    @on '*', (rest...)=>
      @bongos.forEach (bongo)=>
        bongo.handleEvent 'static', @, @getEmitter().event, rest

  ###
  @method: property of the constructor.
  @stub.
  @description: this provides a a getter for the constructor
    which can then be overridden by a subklass, which will in
    any case return a constructor—but maybe not this exact one.
  ###
  @getExactConstructor =(data)-> @
  
  ###
  @method.
  @signature: Base::Uber(arguments...)
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid Uber() when you are using CoffeeScript—
    prefer super().
  ###
  Uber:->
    @constructor.__super__.constructor.apply @, arguments
    
  ###
  @method: property of the constructor.
  @signature: Base.uber(methodName, arguments...)
  @description: Call a method on the superclass.
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid uber() when you are using CoffeeScript—
    prefer super().
  ###
  @uber=(methodName, args...)->
    @__super__.constructor[methodName].apply @, args
  ###
  @method.
  @signature: Base::uber(methodName, arguments...)
  @description: Call a method on the superclass.
  @description: this is sugar to simplify inheritance for
    those who are using Bongo and writing their application
    with JS.  Avoid uber() when you are using CoffeeScript—
    prefer super().
  ###
  uber:(methodName, args...)->
    @constructor.__super__[methodName].apply @, args

  @registerConstructor =->
    unless Base.constructors[@name]?
      Base.constructors[@name] = @
  ###
  @method: property of the constructor
  @signature: Model.set(options)
  @param: component - e.g.:
    - "client" will be passed into setClient()
    - "schema" will be passed into setSchema()
    - "validators" will be passed into setValidators()
  @description: overrides Base.set() and passes items
    to their appropriate setter method.  Ignores items
    that do not have setters.
  ###
  @set =(options)->
    @registerConstructor()
    for own optionName, option of options
      methodName = 
        new Inflector("set_#{Inflector.underscore optionName}")
          .decapitalize()
          .camelize(yes)
          .value
      if 'function' is typeof @[methodName]
        @[methodName] option
      else
        @[optionName] = option
    @
  ###
  @method.
  @signature: Model.setSharedMethods(methods)
  @param: methods - an object containing the following
    properties:
    @property: static - an array of method names to share 
      with the client that should be attached to the
      constructor.
    @property: instance - an array of method names to share 
      with the client that should be attached to the
      prototype.
    @description: methods may be negated if they were
      shared by parent constructors by prefixing the method
      name with one or more "!"s (so don't do double
      negation, because it doesn't seem to make any sense
      in this context.)
  ###
  @setSharedMethods =(methods)->
    for own methodContext, methodNames of methods
      unique = {}
      for methodName in methodNames
        unique[methodName] = yes
      defineProperty @, "#{methodContext}Methods_",
        value: Object.keys unique
    defineProperty @, 'sharedMethods', value: methods, enumerable: yes

  @getSharedMethods =->
    {
      statik    : @staticMethods_ or []
      instance  : @instanceMethods_ or []
    }

  @hasSharedMethod =(method)->
    {statik} = @getSharedMethods()
    method in statik

  hasSharedMethod:(method)->
    {instance} = @constructor.getSharedMethods()
    method in instance

  @share =(global)->
    konstructor = @
    {name} = konstructor
    unless name
      throw new Error "Can't share an unnamed constructor"
    defineProperty konstructor, 'isShared', value: yes
    # TODO: outsource this for scalability reasons.
    # defineProperty constructor, 'sharedInstances', value: {}
    Base.sharedConstructors[name] = konstructor
    Base.globalSharedConstructors[name] = konstructor
    @

  @inheritanceChain =(Klass=@, glue)->
    unless chain = @inheritanceChain_
      proto = Klass.prototype
      chain = [Klass]
      while proto = proto.__proto__
        chain.push proto.constructor
      # memoize the inheritance chain because it ought not to change
      # and it's a bit expensive to have to travese the inheritance
      # chain every time.
      defineProperty @, 'inheritanceChain_', value: chain
    if glue
      (constructor.name for constructor in chain).join glue
    else
      chain

  inheritanceChain:(glue)->
    Base.inheritanceChain @constructor, glue
    
  # emit:(event, data)->
  #   super
  #   id = @getId?() or @bongo_.instanceId
  #   if id? and event isnt 'newListener'
  #     if Array.isArray event
  #       event = event.join('.')
  #     wrappedData = {}
  #     wrappedData[event] = data
  #     @mq?.trigger "updateInstance", "object-#{id}", wrappedData
  
  @setBroadcastable =(@broadcastable_=yes)->

  @getBroadcastable =->
    if @broadcastable_? then @broadcastable_ else yes

  toObjectRef:->
    ref = new ObjectRef @