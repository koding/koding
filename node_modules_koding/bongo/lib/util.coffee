# lib
ObjectId = require './objectid'
# contrib
Traverse = require 'traverse'

module.exports = util =
  asynchronizeOwnMethods:(ofObject)->
    result = {}
    Object.keys(ofObject).forEach (key)->
      if 'function' is typeof fn = ofObject[key]
        result[key] = (rest..., callback)->
          callback fn rest...
    result

  getUnusedKey: do ->
    getCandidate =(key, tryCount)-> key + tryCount
    (keys, key)->
      candidate = key
      tryCount = 0
      while candidate in keys
        candidate = getCandidate key, tryCount++
      candidate

  convertComplexSelector :(selector, constructor, type)->
    new Traverse(selector).map (node)->
      switch @key
        when '$in', '$nin', '$all'
          @update (constructor.castValue(i, type) for i in node), yes
        when '$gt', '$gte', '$lt', '$lte', '$ne'
          @update constructor.castValue(node, type), yes
        when '$or', '$nor', '$and', '$elemMatch', '$not'
          @update util.castAll(node, constructor), yes
        else
          @update node # leaving it untouched; moving on.

  castAll :(selector, constructor)->
    new Traverse(selector).forEach (node)->
      pathName = @path.join '.'
      type = constructor.types?[pathName]
      type ?= ObjectId  if pathName is '_id'

      # we need to consider that mongo selectors can be complex operations
      if type? and node? and 'object' is typeof node
        for key in Object.keys node
          if /^\$/.test key
            @update util.convertComplexSelector(node, constructor, type), yes
            return

      if @key is '_id' and 'string' is typeof node and not type?
        @update new ObjectId(node), yes unless constructor.dontAutoCastId
      else if type is String and node instanceof RegExp
        @update node
      else if not @isRoot and constructor.castValue? and type?
        @update constructor.castValue(node, type), yes