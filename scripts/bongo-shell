#!/usr/bin/env coffee
# -c config file
# -f eval coffeescript file
# -C run -f file when a bongo model is reloaded
fs       = require 'fs'
vm       = require 'vm'
nesh     = require('nesh')
Bongo    = require 'bongo'
Broker   = require 'broker'
{argv}   = require 'optimist'
{extend} = require 'underscore'

process.on 'uncaughtException', (err)->
  console.log "!!!!!!!!!!!!!!!!!!!!!!!! uncaughtException !!!!!!!!!!!!!!!!!!"
  console.error err

if argv.c
  KONFIG = require('koding-config-manager').load("main.#{argv.c}")  
else
  KONFIG = require('koding-config-manager').load("main.vagrant")

{mongo, mq, projectRoot, webserver} = KONFIG

mqOptions = extend {}, mq
mqOptions.login = webserver.login  if webserver?.login?
mqOptions.productName = 'koding-webserver'

opts =
  welcome: 'Welcome to koding...'
  prompt: 'bongo> '

nesh.config.load()
nesh.loadLanguage('coffee')

lastHash = ""
repl_ = null

hashFile = (f)->
  crypto = require('crypto')
  shasum = crypto.createHash('sha1')
  shasum.update(fs.readFileSync f)
  return shasum.digest('hex')

# these are for fake remote method calls...
class RemoteProxy
  constructor: (@objectName, @type)->

  callmethod: (methodName, args...)->
    if @type is "instance"
      method = 
        type: 'instance', 
        method: methodName, 
        constructorName: @objectName, 
        id: @object._id
    else if @type is "static"
      method = type: 'static', method: methodName, constructorName: @objectName
    bongo.invokeMethod method, args, "secretname", "sessiontoken"

remoteRegistry = {}
remoteRegistryForInstances = {}

remoteMethodGenerator = (methodName)->
  (args...)-> 
    @callmethod methodName, args...

createRemoteRegistry = ()->
  for m, klass of bongo.models    
    if klass.sharedMethods?.static?
      remoteRegistry[m] = new RemoteProxy m, "static"
      for method in klass.sharedMethods.static
        remoteRegistry[m][method] = remoteMethodGenerator(method)
    if klass.sharedMethods?.instance?
      remoteRegistryForInstances[m] = new RemoteProxy m, "instance"
      for method in klass.sharedMethods.instance
        remoteRegistryForInstances[m][method] = remoteMethodGenerator(method)

codeReload = (f)->
  # dead simple code reloading function
  # we load the bongo model in a new context
  # then get its instance methods, class methods
  # and redefine it on our model instance
  # thank god for dynamic languages
  try
    code = nesh.compile fs.readFileSync f, 'utf-8'
  catch E
    console.log "error while loading code... #{f}"
    console.error E
    return 

  code = """
  mdl = require '#{f}'
  """
  code = nesh.compile code
  sandbox = 
    require: require
    console: console

  delete require.cache[f]
  vm.runInNewContext code, sandbox
  ourModel = bongo.models[sandbox.mdl.name]
  newInstanceMethods = {}
  newClassMethods = {}
  if ourModel?
    # TODO: shorten me please...
    # we first update instance methods
    for own key, value of sandbox.mdl.prototype
      if typeof(value) is "function"
        ourModel.prototype[key] = value
        newInstanceMethods[key] = 1
    # then update classmethods
    for own key, value of sandbox.mdl
      if typeof(value) is "function"
        ourModel[key] = value
        newClassMethods[key] = 1 

    # now we remove the deleted functions
    for own key, value of ourModel.prototype
      if typeof(value) is "function"
        if not newInstanceMethods[key]?
          delete ourModel.prototype[key]

    # now we remove the deleted functions
    for own key, value of ourModel
      if typeof(value) is "function"
        if not newClassMethods[key]?
          delete ourModel[key]

    # we update shared instance methods, and shared class methods too
    ourModel.sharedMethods.instance = sandbox.mdl.sharedMethods.instance
    ourModel.sharedMethods.static = sandbox.mdl.sharedMethods.static

    # console.log "instance methods-----"
    # console.log sandbox.mdl.sharedMethods.instance
    # console.log ourModel.sharedMethods.instance
    # console.log "---- instance methods ---"
    createRemoteRegistry()

  if argv.C
    console.log "running file..."
    loadAndRunFile(argv.f, true)


loadAndRunFile = (f, force=false)->
  hash = hashFile(argv.f)
  if hash isnt lastHash or force
    console.log ">>>> fileChanged executing..."
    execFile(argv.f, repl_)
    lastHash = hash


remote = (object)->
  if typeof object is "function" and object.name?
    return remoteRegistry[object.name]
  else if typeof object is "object" and object.bongo_?.constructorName?
    proxyObject = remoteRegistryForInstances[object.bongo_.constructorName]
    proxyObject.object = object
    return proxyObject
  else 
    throw "Wrong type"

Watcher = require 'koding-watcher'
bongoPlugin =
    name: "bongoplugin"
    description: "Some description here"
    setup: (context, next) ->
      {defaults} = context
      next()

    preStart: (context, next) ->
      {options} = context
      next()

    postStart: (context, next)->
      {repl} = context
      repl_ = repl
      if argv.f
        fs.watch argv.f, (event)->
          loadAndRunFile argv.f

      repl.context.md5 = (value) ->
        crypto.createHash('md5').update(value).digest 'hex'

      repl.context.bongo = bongo
      for i of bongo.models
        repl.context[i] = bongo.models[i]
      repl.context.authenticator = authenticator
      repl.context.Bongo = Bongo
      repl.context.remote = remote
      repl.context.remoteRegistry = remoteRegistry
      repl.context.remoteRegistryForInstances = remoteRegistryForInstances

      createRemoteRegistry()

      console.log "Press enter to start"

      watcher = new Watcher
        groups        :
          bongo      :
            folders   : [projectRoot + '/workers/social/lib/social/models']
            onChange  : (path)->
              console.log "#{path} changed"
              codeReload(path)
      next()

execFile = (f, repl)->
  try
    data = nesh.compile fs.readFileSync f, 'utf-8'
    vm.runInContext data, repl.context
  catch E
    console.error E

startShell = ()->
  nesh.loadPlugin bongoPlugin, (err) ->
    nesh.log.error err if err
    if argv.f
      opts.evalData = nesh.compile fs.readFileSync argv.f, 'utf-8'
    nesh.start opts, (err)->
      if (err)
        nesh.log.error(err)

Bongo.throwIt = (it)->
  console.error it

class BongoWithOnReady extends Bongo

  constructor: (options)->
    @on 'newModel', (m)->
      console.log "loaded model", m

    @on 'ready', ()->
      console.log "Bongo is ready"

    @on 'newInstance', ()->
      # TODO: couldnt find a better solution then 
      # adding timeout. Checked events but this is
      # the only solution to make it work in node v.0.8
      setTimeout ()->
        startShell()
      , 1000
    super(options)

class Authenticator

  constructor: (@account)->

  setAccount: (who, callback)->
    bongo.models.JAccount.one {'profile.nickname': who}, (err, account)=>
      @account = account
      callback err, account

  fetchClient: (sessionToken, context, callback)->
    callback {sessionToken, context, connection:delegate:@account}

authenticator = new Authenticator

bongo = new BongoWithOnReady {
  mongo : "mongodb://#{mongo}?auto_reconnect"
  root: projectRoot
  models: 'workers/social/lib/social/models'
  mq: new Broker mqOptions
  resourceName: webserver.queueName,
  fetchClient: (sessionToken, context, callback)->
    return authenticator.fetchClient sessionToken, context, callback
}


